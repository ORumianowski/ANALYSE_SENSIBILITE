ggplot() +
geom_line(data = effectif, aes(x = temps, y = S, color = "Susceptible"), size = 1) +
geom_line(data = effectif, aes(x = temps, y = Incub, color = "Infected"), size = 1) +
geom_line(data = effectif, aes(x = temps, y = Infec, color = "Infectious"), size = 1) +
geom_line(data = effectif, aes(x = temps, y = R, color = "Recovered"), size = 1) +
labs(x = "Time", y = "Population") +
#scale_color_manual(values = c("Susceptible" = "blue", "Infected" = "red", "Recovered" = "green")) +
theme_minimal() +
ggtitle("Multiple Repetitions of SIR Model with Different Parameters")
ggplot() +
geom_line(data = effectif, aes(x = temps, y = S, color = "Susceptible"), size = 1) +
geom_line(data = effectif, aes(x = temps, y = Incub, color = "Infected"), size = 1) +
geom_line(data = effectif, aes(x = temps, y = Infec, color = "Infectious"), size = 1) +
geom_line(data = effectif, aes(x = temps, y = R, color = "Recovered"), size = 1) +
labs(x = "Time", y = "Population") +
theme_minimal() +
ggtitle("Multiple Repetitions of SIR Model with Different Parameters")
ggplot() +
geom_line(data = effectif, aes(x = temps, y = S, color = "1- Susceptible"), size = 1) +
geom_line(data = effectif, aes(x = temps, y = Incub, color = "2- Infected"), size = 1) +
geom_line(data = effectif, aes(x = temps, y = Infec, color = "3- Infectious"), size = 1) +
geom_line(data = effectif, aes(x = temps, y = R, color = "4- Recovered"), size = 1) +
labs(x = "Time", y = "Population") +
theme_minimal() +
ggtitle("Multiple Repetitions of SIR Model with Different Parameters")
library(tidyverse)
### Mod?le dont la sensibilit? doit ?tre analys?e dans le cadre du projet MODE-MPI 2023-2024
### Le mod?le est ici d?fini sous forme de fonction pour faciliter vos analyses de sensibilit? (AS)
### La fonction renvoie les sorties ponctuelles qui sont ? analyser dans l'AS
modAppli <- function(parametre){
# CONDITIONS DE SIMULATION
temps = 2*365; # nb de pas de temps (en jours)
# initialisation pour la sauvegarde de 4 sorties ponctuelles pour chaque jeu de param?tres
sorties <- matrix(0, nrow=nrow(parametre), ncol=4)
# boucle des sc?narios de l'?chantillonnage de l'AS
for (i in 1:nrow(parametre)) {
# STRUCTURE & PARAMETRES DU MODELE
# XX
K = parametre[i,1] ;		# xx
sr = parametre[i,2] ;	# xx
m1 = parametre[i,3] ;	# xx
m2 = parametre[i,4] ;	# xx
m3 = parametre[i,5] ;	# xx
f2 = parametre[i,6] ;	# xx
f3 = parametre[i,7] ;	# xx
portee = parametre[i,8] ;	# xx
t1 = parametre[i,9] ;	# xx
t2 = parametre[i,10] ;	# xx
# XX
trans = parametre[i,11] ; # xx
lat = parametre[i,12] ;	# xx
rec = parametre[i,13] ;	# xx
loss = parametre[i,14] ;	# xx
madd = parametre[i,15] ;	# xx
# INITIALISATION
MAT <- array(0, dim=c(4,4,temps)); # nb indiv par classe d'?ge en ligne (derni?re ligne = pop tot), ?tat de sant? en colonne, pas de temps (dimension 3)
nvinf <- array(0, dim=c(temps));
# conditions initiales (la population est ? sa structure d'?quilibre, calcul?e par ailleurs)
MAT[1,1,1] <- 27; # xx
MAT[2,1,1] <- 23; # xx
MAT[3,1,1] <- 36; # xx
MAT[3,3,1] <- 1;  # xx
# effectifs par ?tat de sant?
MAT[4,1,1] <- sum(MAT[1:3,1,1]); MAT[4,2,1] <- sum(MAT[1:3,2,1]); MAT[4,3,1] <- sum(MAT[1:3,3,1]); MAT[4,4,1] <- sum(MAT[1:3,4,1]);
# SIMULATIONS
# boucle du temps
for (t in 1:(temps-1)) {
# classe d'?ge xx
# RQ : les naissances sont XX, les nouveaux n?s ?tant dans l'?tat XX
N <- sum(MAT[4,,t]);	# taille de la pop en t
MAT[1,1,t+1] <- MAT[1,1,t]*(1-m1-t1-trans*MAT[4,3,t]/N) + loss*MAT[1,4,t]      + max(0, sr*portee*(sum(MAT[2,,t])*f2 + sum(MAT[3,,t])*f3) * (1 - N/K));
MAT[1,2,t+1] <- MAT[1,2,t]*(1-m1-t1-lat)			  + trans*MAT[1,1,t]*MAT[4,3,t]/N;
MAT[1,3,t+1] <- MAT[1,3,t]*(1-m1-madd-t1-rec)  		  + lat*MAT[1,2,t];
MAT[1,4,t+1] <- MAT[1,4,t]*(1-m1-t1-loss) 		  + rec*MAT[1,3,t];
# classe d'?ge xx
MAT[2,1,t+1] <- MAT[1,1,t]*t1	+ MAT[2,1,t]*(1-m2-t2-trans*MAT[4,3,t]/N) + loss*MAT[2,4,t];
MAT[2,2,t+1] <- MAT[1,2,t]*t1	+ MAT[2,2,t]*(1-m2-t2-lat)			+ trans*MAT[2,1,t]*MAT[4,3,t]/N;
MAT[2,3,t+1] <- MAT[1,3,t]*t1	+ MAT[2,3,t]*(1-m2-madd-t2-rec)		+ lat*MAT[2,2,t];
MAT[2,4,t+1] <- MAT[1,4,t]*t1	+ MAT[2,4,t]*(1-m2-t2-loss)			+ rec*MAT[2,3,t];
# classe d'?ge xx
MAT[3,1,t+1] <- MAT[2,1,t]*t2	+ MAT[3,1,t]*(1-m3-trans*MAT[4,3,t]/N) 	+ loss*MAT[3,4,t];
MAT[3,2,t+1] <- MAT[2,2,t]*t2	+ MAT[3,2,t]*(1-m3-lat)				+ trans*MAT[3,1,t]*MAT[4,3,t]/N;
MAT[3,3,t+1] <- MAT[2,3,t]*t2	+ MAT[3,3,t]*(1-m3-madd-rec)			+ lat*MAT[3,2,t];
MAT[3,4,t+1] <- MAT[2,4,t]*t2	+ MAT[3,4,t]*(1-m3-loss)			+ rec*MAT[3,3,t];
# calcul des effectifs par ?tat de sant?
MAT[4,1,t+1] <- sum(MAT[1:3,1,t+1]); MAT[4,2,t+1] <- sum(MAT[1:3,2,t+1]); MAT[4,3,t+1] <- sum(MAT[1:3,3,t+1]); MAT[4,4,t+1] <- sum(MAT[1:3,4,t+1]);
nvinf[t+1]   <- trans*MAT[4,1,t]*MAT[4,3,t]/N
}# fin boucle temps
# sorties ponctuelles ? analyser
# XX
sortie1 <- (MAT[4,2,temps]+MAT[4,3,temps])/sum(MAT[4,,temps]) # proportion de malade (infectieux ou non) à la fin
# xx
sortie2 <- nvinf[temps] # nombre d'infection à la fin
# xx
sortie3 <- max(MAT[4,3,1:temps]) # ?effectif maximal de malades infectieux
# xx
sortie4 <- sum(nvinf[1:365]) #nombre d'infection la première année
sorties[i,1] <- sortie1;
sorties[i,2] <- sortie2;
sorties[i,3] <- sortie3;
sorties[i,4] <- sortie4;
}# fin boucle sc?narios AS
res = list(sorties, MAT, nvinf)
return(res)
} # fin fonction du mod?le
# END
ValNominale = c(100, 0.5, 0.0014, 0.00029, 0.0019,
0.0019, 0.0082, 5, 1/365, 1/365,
0.3, 1/5, 1/20, 1/100, 0.001)
scenario_initial = matrix(ValNominale, nrow=1, ncol=15)
res = modAppli(scenario_initial)
effectif = tibble(
temps = 1:(2*365),
S = res[[2]][4,1,],
Incub = res[[2]][4,2,],
Infec = res[[2]][4,3,],
R = res[[2]][4,4,])
ggplot() +
geom_line(data = effectif, aes(x = temps, y = S, color = "1- Susceptible"), size = 1) +
geom_line(data = effectif, aes(x = temps, y = Incub, color = "2- Infected"), size = 1) +
geom_line(data = effectif, aes(x = temps, y = Infec, color = "3- Infectious"), size = 1) +
geom_line(data = effectif, aes(x = temps, y = R, color = "4- Recovered"), size = 1) +
labs(x = "Time", y = "Population") +
theme_minimal() +
ggtitle("Initial Model")
effectif = tibble(
temps = 1:(2*365),
S = res[[2]][4,1,],
L = res[[2]][4,2,],
I = res[[2]][4,3,],
R = res[[2]][4,4,],
N = sum(MAT[4,,]))
effectif = tibble(
temps = 1:(2*365),
S = res[[2]][4,1,],
L = res[[2]][4,2,],
I = res[[2]][4,3,],
R = res[[2]][4,4,],
N = sum(res[[2]][4,,]))
library(tidyverse)
### Mod?le dont la sensibilit? doit ?tre analys?e dans le cadre du projet MODE-MPI 2023-2024
### Le mod?le est ici d?fini sous forme de fonction pour faciliter vos analyses de sensibilit? (AS)
### La fonction renvoie les sorties ponctuelles qui sont ? analyser dans l'AS
modAppli <- function(parametre){
# CONDITIONS DE SIMULATION
temps = 2*365; # nb de pas de temps (en jours)
# initialisation pour la sauvegarde de 4 sorties ponctuelles pour chaque jeu de param?tres
sorties <- matrix(0, nrow=nrow(parametre), ncol=4)
# boucle des sc?narios de l'?chantillonnage de l'AS
for (i in 1:nrow(parametre)) {
# STRUCTURE & PARAMETRES DU MODELE
# XX
K = parametre[i,1] ;		# xx
sr = parametre[i,2] ;	# xx
m1 = parametre[i,3] ;	# xx
m2 = parametre[i,4] ;	# xx
m3 = parametre[i,5] ;	# xx
f2 = parametre[i,6] ;	# xx
f3 = parametre[i,7] ;	# xx
portee = parametre[i,8] ;	# xx
t1 = parametre[i,9] ;	# xx
t2 = parametre[i,10] ;	# xx
# XX
trans = parametre[i,11] ; # xx
lat = parametre[i,12] ;	# xx
rec = parametre[i,13] ;	# xx
loss = parametre[i,14] ;	# xx
madd = parametre[i,15] ;	# xx
# INITIALISATION
MAT <- array(0, dim=c(4,4,temps)); # nb indiv par classe d'?ge en ligne (derni?re ligne = pop tot), ?tat de sant? en colonne, pas de temps (dimension 3)
nvinf <- array(0, dim=c(temps));
# conditions initiales (la population est ? sa structure d'?quilibre, calcul?e par ailleurs)
MAT[1,1,1] <- 27; # xx
MAT[2,1,1] <- 23; # xx
MAT[3,1,1] <- 36; # xx
MAT[3,3,1] <- 1;  # xx
# effectifs par ?tat de sant?
MAT[4,1,1] <- sum(MAT[1:3,1,1]); MAT[4,2,1] <- sum(MAT[1:3,2,1]); MAT[4,3,1] <- sum(MAT[1:3,3,1]); MAT[4,4,1] <- sum(MAT[1:3,4,1]);
# SIMULATIONS
# boucle du temps
for (t in 1:(temps-1)) {
# classe d'?ge xx
# RQ : les naissances sont XX, les nouveaux n?s ?tant dans l'?tat XX
N <- sum(MAT[4,,t]);	# taille de la pop en t
MAT[1,1,t+1] <- MAT[1,1,t]*(1-m1-t1-trans*MAT[4,3,t]/N) + loss*MAT[1,4,t]      + max(0, sr*portee*(sum(MAT[2,,t])*f2 + sum(MAT[3,,t])*f3) * (1 - N/K));
MAT[1,2,t+1] <- MAT[1,2,t]*(1-m1-t1-lat)			  + trans*MAT[1,1,t]*MAT[4,3,t]/N;
MAT[1,3,t+1] <- MAT[1,3,t]*(1-m1-madd-t1-rec)  		  + lat*MAT[1,2,t];
MAT[1,4,t+1] <- MAT[1,4,t]*(1-m1-t1-loss) 		  + rec*MAT[1,3,t];
# classe d'?ge xx
MAT[2,1,t+1] <- MAT[1,1,t]*t1	+ MAT[2,1,t]*(1-m2-t2-trans*MAT[4,3,t]/N) + loss*MAT[2,4,t];
MAT[2,2,t+1] <- MAT[1,2,t]*t1	+ MAT[2,2,t]*(1-m2-t2-lat)			+ trans*MAT[2,1,t]*MAT[4,3,t]/N;
MAT[2,3,t+1] <- MAT[1,3,t]*t1	+ MAT[2,3,t]*(1-m2-madd-t2-rec)		+ lat*MAT[2,2,t];
MAT[2,4,t+1] <- MAT[1,4,t]*t1	+ MAT[2,4,t]*(1-m2-t2-loss)			+ rec*MAT[2,3,t];
# classe d'?ge xx
MAT[3,1,t+1] <- MAT[2,1,t]*t2	+ MAT[3,1,t]*(1-m3-trans*MAT[4,3,t]/N) 	+ loss*MAT[3,4,t];
MAT[3,2,t+1] <- MAT[2,2,t]*t2	+ MAT[3,2,t]*(1-m3-lat)				+ trans*MAT[3,1,t]*MAT[4,3,t]/N;
MAT[3,3,t+1] <- MAT[2,3,t]*t2	+ MAT[3,3,t]*(1-m3-madd-rec)			+ lat*MAT[3,2,t];
MAT[3,4,t+1] <- MAT[2,4,t]*t2	+ MAT[3,4,t]*(1-m3-loss)			+ rec*MAT[3,3,t];
# calcul des effectifs par ?tat de sant?
MAT[4,1,t+1] <- sum(MAT[1:3,1,t+1]); MAT[4,2,t+1] <- sum(MAT[1:3,2,t+1]); MAT[4,3,t+1] <- sum(MAT[1:3,3,t+1]); MAT[4,4,t+1] <- sum(MAT[1:3,4,t+1]);
nvinf[t+1]   <- trans*MAT[4,1,t]*MAT[4,3,t]/N
}# fin boucle temps
# sorties ponctuelles ? analyser
# XX
sortie1 <- (MAT[4,2,temps]+MAT[4,3,temps])/sum(MAT[4,,temps]) # proportion de malade (infectieux ou non) à la fin
# xx
sortie2 <- nvinf[temps] # nombre d'infection à la fin
# xx
sortie3 <- max(MAT[4,3,1:temps]) # ?effectif maximal de malades infectieux
# xx
sortie4 <- sum(nvinf[1:365]) #nombre d'infection la première année
sorties[i,1] <- sortie1;
sorties[i,2] <- sortie2;
sorties[i,3] <- sortie3;
sorties[i,4] <- sortie4;
}# fin boucle sc?narios AS
res = list(sorties, MAT, nvinf)
return(res)
} # fin fonction du mod?le
# END
ValNominale = c(100, 0.5, 0.0014, 0.00029, 0.0019,
0.0019, 0.0082, 5, 1/365, 1/365,
0.3, 1/5, 1/20, 1/100, 0.001)
scenario_initial = matrix(ValNominale, nrow=1, ncol=15)
res = modAppli(scenario_initial)
effectif = tibble(
temps = 1:(2*365),
S = res[[2]][4,1,],
L = res[[2]][4,2,],
I = res[[2]][4,3,],
R = res[[2]][4,4,],
N = sum(res[[2]][4,,]))
ggplot() +
geom_line(data = effectif, aes(x = temps, y = S, color = "1- Susceptible"), size = 1) +
geom_line(data = effectif, aes(x = temps, y = L, color = "2- Latent"), size = 1) +
geom_line(data = effectif, aes(x = temps, y = I, color = "3- Infectious"), size = 1) +
geom_line(data = effectif, aes(x = temps, y = R, color = "4- Recovered"), size = 1) +
geom_line(data = effectif, aes(x = temps, y = N, color = "Population Size"), size = 1) +
labs(x = "Time", y = "Population") +
theme_minimal() +
ggtitle("Initial Model")
effectif = tibble(
temps = 1:(2*365),
S = res[[2]][4,1,],
L = res[[2]][4,2,],
I = res[[2]][4,3,],
R = res[[2]][4,4,],
N = S + L + I + R)
ggplot() +
geom_line(data = effectif, aes(x = temps, y = S, color = "1- Susceptible"), size = 1) +
geom_line(data = effectif, aes(x = temps, y = L, color = "2- Latent"), size = 1) +
geom_line(data = effectif, aes(x = temps, y = I, color = "3- Infectious"), size = 1) +
geom_line(data = effectif, aes(x = temps, y = R, color = "4- Recovered"), size = 1) +
geom_line(data = effectif, aes(x = temps, y = N, color = "Population Size"), size = 1) +
labs(x = "Time", y = "Population") +
theme_minimal() +
ggtitle("Initial Model")
nvinf
library(tidyverse)
library(ggpubr)
### Mod?le dont la sensibilit? doit ?tre analys?e dans le cadre du projet MODE-MPI 2023-2024
### Le mod?le est ici d?fini sous forme de fonction pour faciliter vos analyses de sensibilit? (AS)
### La fonction renvoie les sorties ponctuelles qui sont ? analyser dans l'AS
modAppli <- function(parametre){
# CONDITIONS DE SIMULATION
temps = 2*365; # nb de pas de temps (en jours)
# initialisation pour la sauvegarde de 4 sorties ponctuelles pour chaque jeu de param?tres
sorties <- matrix(0, nrow=nrow(parametre), ncol=4)
# boucle des sc?narios de l'?chantillonnage de l'AS
for (i in 1:nrow(parametre)) {
# STRUCTURE & PARAMETRES DU MODELE
# XX
K = parametre[i,1] ;		# xx
sr = parametre[i,2] ;	# xx
m1 = parametre[i,3] ;	# xx
m2 = parametre[i,4] ;	# xx
m3 = parametre[i,5] ;	# xx
f2 = parametre[i,6] ;	# xx
f3 = parametre[i,7] ;	# xx
portee = parametre[i,8] ;	# xx
t1 = parametre[i,9] ;	# xx
t2 = parametre[i,10] ;	# xx
# XX
trans = parametre[i,11] ; # xx
lat = parametre[i,12] ;	# xx
rec = parametre[i,13] ;	# xx
loss = parametre[i,14] ;	# xx
madd = parametre[i,15] ;	# xx
# INITIALISATION
MAT <- array(0, dim=c(4,4,temps)); # nb indiv par classe d'?ge en ligne (derni?re ligne = pop tot), ?tat de sant? en colonne, pas de temps (dimension 3)
nvinf <- array(0, dim=c(temps));
# conditions initiales (la population est ? sa structure d'?quilibre, calcul?e par ailleurs)
MAT[1,1,1] <- 27; # xx
MAT[2,1,1] <- 23; # xx
MAT[3,1,1] <- 36; # xx
MAT[3,3,1] <- 1;  # xx
# effectifs par ?tat de sant?
MAT[4,1,1] <- sum(MAT[1:3,1,1]); MAT[4,2,1] <- sum(MAT[1:3,2,1]); MAT[4,3,1] <- sum(MAT[1:3,3,1]); MAT[4,4,1] <- sum(MAT[1:3,4,1]);
# SIMULATIONS
# boucle du temps
for (t in 1:(temps-1)) {
# classe d'?ge xx
# RQ : les naissances sont XX, les nouveaux n?s ?tant dans l'?tat XX
N <- sum(MAT[4,,t]);	# taille de la pop en t
MAT[1,1,t+1] <- MAT[1,1,t]*(1-m1-t1-trans*MAT[4,3,t]/N) + loss*MAT[1,4,t]      + max(0, sr*portee*(sum(MAT[2,,t])*f2 + sum(MAT[3,,t])*f3) * (1 - N/K));
MAT[1,2,t+1] <- MAT[1,2,t]*(1-m1-t1-lat)			  + trans*MAT[1,1,t]*MAT[4,3,t]/N;
MAT[1,3,t+1] <- MAT[1,3,t]*(1-m1-madd-t1-rec)  		  + lat*MAT[1,2,t];
MAT[1,4,t+1] <- MAT[1,4,t]*(1-m1-t1-loss) 		  + rec*MAT[1,3,t];
# classe d'?ge xx
MAT[2,1,t+1] <- MAT[1,1,t]*t1	+ MAT[2,1,t]*(1-m2-t2-trans*MAT[4,3,t]/N) + loss*MAT[2,4,t];
MAT[2,2,t+1] <- MAT[1,2,t]*t1	+ MAT[2,2,t]*(1-m2-t2-lat)			+ trans*MAT[2,1,t]*MAT[4,3,t]/N;
MAT[2,3,t+1] <- MAT[1,3,t]*t1	+ MAT[2,3,t]*(1-m2-madd-t2-rec)		+ lat*MAT[2,2,t];
MAT[2,4,t+1] <- MAT[1,4,t]*t1	+ MAT[2,4,t]*(1-m2-t2-loss)			+ rec*MAT[2,3,t];
# classe d'?ge xx
MAT[3,1,t+1] <- MAT[2,1,t]*t2	+ MAT[3,1,t]*(1-m3-trans*MAT[4,3,t]/N) 	+ loss*MAT[3,4,t];
MAT[3,2,t+1] <- MAT[2,2,t]*t2	+ MAT[3,2,t]*(1-m3-lat)				+ trans*MAT[3,1,t]*MAT[4,3,t]/N;
MAT[3,3,t+1] <- MAT[2,3,t]*t2	+ MAT[3,3,t]*(1-m3-madd-rec)			+ lat*MAT[3,2,t];
MAT[3,4,t+1] <- MAT[2,4,t]*t2	+ MAT[3,4,t]*(1-m3-loss)			+ rec*MAT[3,3,t];
# calcul des effectifs par ?tat de sant?
MAT[4,1,t+1] <- sum(MAT[1:3,1,t+1]); MAT[4,2,t+1] <- sum(MAT[1:3,2,t+1]); MAT[4,3,t+1] <- sum(MAT[1:3,3,t+1]); MAT[4,4,t+1] <- sum(MAT[1:3,4,t+1]);
nvinf[t+1]   <- trans*MAT[4,1,t]*MAT[4,3,t]/N
}# fin boucle temps
# sorties ponctuelles ? analyser
# XX
sortie1 <- (MAT[4,2,temps]+MAT[4,3,temps])/sum(MAT[4,,temps]) # proportion de malade (infectieux ou non) à la fin
# xx
sortie2 <- nvinf[temps] # nombre d'infection à la fin
# xx
sortie3 <- max(MAT[4,3,1:temps]) # ?effectif maximal de malades infectieux
# xx
sortie4 <- sum(nvinf[1:365]) #nombre d'infection la première année
sorties[i,1] <- sortie1;
sorties[i,2] <- sortie2;
sorties[i,3] <- sortie3;
sorties[i,4] <- sortie4;
}# fin boucle sc?narios AS
return(sorties)
} # fin fonction du mod?le
# END
ValNominale = c(100,
0.5, 0.0014, 0.00029, 0.0019,
0.0019, 0.0082, 5, 1/365, 1/365,
0.3, 1/5, 1/20, 1/100, 0.001)
scenario_initial = matrix(ValNominale, nrow=1, ncol=15)
res = modAppli(scenario_initial)
scenario_OAT = rbind(ValNominale,ValNominale,ValNominale,ValNominale,ValNominale,
ValNominale,ValNominale,ValNominale,ValNominale,ValNominale, ValNominale)
graph_oat = function(i, bornes){
scenario_OAT_i = scenario_OAT
if (bornes[1] != Inf){
inf = bornes[1]
sup = bornes[2]
scenario_OAT_i[, i] = c(ValNominale[i],
inf + (sup-inf)  * c(0, 0.01, 0.1, 0.3, 0.4, 0.5, 0.7, 0.9, 0.99, 1)
)
}
else{
scenario_OAT_i[, i] = ValNominale[i] * c(1,
0, 1/100, 1/10, 1/5, 0.9,
1.1, 2, 5, 10, 100)
}
res = modAppli(scenario_OAT_i)
fina = tibble(paramettre_i = scenario_OAT_i[, i],
prop_inf = res[,1]/res[1,1],
infec_end = res[,2]/res[1,2],
nb_max_infec = res[,3]/res[1,3] ,
nb_infec_year1 = res[,4]/res[1,4])
ggplot() +
geom_line(data = fina, aes(x = paramettre_i, y = prop_inf, color = "S1"), size = 1) +
geom_line(data = fina, aes(x = paramettre_i, y = infec_end, color = "S2"), size = 1) +
geom_line(data = fina, aes(x = paramettre_i, y = nb_max_infec,  color = "S3"), size = 1) +
geom_line(data = fina, aes(x = paramettre_i, y = nb_infec_year1,  color = "S4"), size = 1) +
scale_x_continuous(trans='log10') +
labs(x = "Parameter value", y = "Relative variation") +
theme_minimal() +
ggtitle(i)
}
graph_oat(i = 1, bornes = c(0, 500))
graph_oat(i = 1, bornes = c(Inf, Inf))
ggarrange(graph_oat(i = 1, bornes = c(Inf, Inf)), graph_oat(i = 2, bornes = c(Inf, Inf)), graph_oat(i = 3, bornes = c(Inf, Inf)),
graph_oat(i = 4, bornes = c(Inf, Inf)), graph_oat(i = 4, bornes = c(Inf, Inf)), graph_oat(i = 5, bornes = c(Inf, Inf)),
graph_oat(i = 7, bornes = c(Inf, Inf)), graph_oat(i = 8, bornes = c(Inf, Inf)), graph_oat(i = 9, bornes = c(Inf, Inf)),
graph_oat(i = 10, bornes = c(Inf, Inf)), graph_oat(i = 11, bornes = c(0, 1)), graph_oat(i = 12, bornes = c(0, 1)),
graph_oat(i = 13, bornes = c(0, 1)), graph_oat(i = 14, bornes = c(0, 1)), graph_oat(i = 15, bornes = c(0, 1)),
ncol = 3, nrow = 5)
library(tidyverse)
library(ggpubr)
### Mod?le dont la sensibilit? doit ?tre analys?e dans le cadre du projet MODE-MPI 2023-2024
### Le mod?le est ici d?fini sous forme de fonction pour faciliter vos analyses de sensibilit? (AS)
### La fonction renvoie les sorties ponctuelles qui sont ? analyser dans l'AS
modAppli <- function(parametre){
# CONDITIONS DE SIMULATION
temps = 2*365; # nb de pas de temps (en jours)
# initialisation pour la sauvegarde de 4 sorties ponctuelles pour chaque jeu de param?tres
sorties <- matrix(0, nrow=nrow(parametre), ncol=4)
# boucle des sc?narios de l'?chantillonnage de l'AS
for (i in 1:nrow(parametre)) {
# STRUCTURE & PARAMETRES DU MODELE
# XX
K = parametre[i,1] ;		# xx
sr = parametre[i,2] ;	# xx
m1 = parametre[i,3] ;	# xx
m2 = parametre[i,4] ;	# xx
m3 = parametre[i,5] ;	# xx
f2 = parametre[i,6] ;	# xx
f3 = parametre[i,7] ;	# xx
portee = parametre[i,8] ;	# xx
t1 = parametre[i,9] ;	# xx
t2 = parametre[i,10] ;	# xx
# XX
trans = parametre[i,11] ; # xx
lat = parametre[i,12] ;	# xx
rec = parametre[i,13] ;	# xx
loss = parametre[i,14] ;	# xx
madd = parametre[i,15] ;	# xx
# INITIALISATION
MAT <- array(0, dim=c(4,4,temps)); # nb indiv par classe d'?ge en ligne (derni?re ligne = pop tot), ?tat de sant? en colonne, pas de temps (dimension 3)
nvinf <- array(0, dim=c(temps));
# conditions initiales (la population est ? sa structure d'?quilibre, calcul?e par ailleurs)
MAT[1,1,1] <- 27; # xx
MAT[2,1,1] <- 23; # xx
MAT[3,1,1] <- 36; # xx
MAT[3,3,1] <- 1;  # xx
# effectifs par ?tat de sant?
MAT[4,1,1] <- sum(MAT[1:3,1,1]); MAT[4,2,1] <- sum(MAT[1:3,2,1]); MAT[4,3,1] <- sum(MAT[1:3,3,1]); MAT[4,4,1] <- sum(MAT[1:3,4,1]);
# SIMULATIONS
# boucle du temps
for (t in 1:(temps-1)) {
# classe d'?ge xx
# RQ : les naissances sont XX, les nouveaux n?s ?tant dans l'?tat XX
N <- sum(MAT[4,,t]);	# taille de la pop en t
MAT[1,1,t+1] <- MAT[1,1,t]*(1-m1-t1-trans*MAT[4,3,t]/N) + loss*MAT[1,4,t]      + max(0, sr*portee*(sum(MAT[2,,t])*f2 + sum(MAT[3,,t])*f3) * (1 - N/K));
MAT[1,2,t+1] <- MAT[1,2,t]*(1-m1-t1-lat)			  + trans*MAT[1,1,t]*MAT[4,3,t]/N;
MAT[1,3,t+1] <- MAT[1,3,t]*(1-m1-madd-t1-rec)  		  + lat*MAT[1,2,t];
MAT[1,4,t+1] <- MAT[1,4,t]*(1-m1-t1-loss) 		  + rec*MAT[1,3,t];
# classe d'?ge xx
MAT[2,1,t+1] <- MAT[1,1,t]*t1	+ MAT[2,1,t]*(1-m2-t2-trans*MAT[4,3,t]/N) + loss*MAT[2,4,t];
MAT[2,2,t+1] <- MAT[1,2,t]*t1	+ MAT[2,2,t]*(1-m2-t2-lat)			+ trans*MAT[2,1,t]*MAT[4,3,t]/N;
MAT[2,3,t+1] <- MAT[1,3,t]*t1	+ MAT[2,3,t]*(1-m2-madd-t2-rec)		+ lat*MAT[2,2,t];
MAT[2,4,t+1] <- MAT[1,4,t]*t1	+ MAT[2,4,t]*(1-m2-t2-loss)			+ rec*MAT[2,3,t];
# classe d'?ge xx
MAT[3,1,t+1] <- MAT[2,1,t]*t2	+ MAT[3,1,t]*(1-m3-trans*MAT[4,3,t]/N) 	+ loss*MAT[3,4,t];
MAT[3,2,t+1] <- MAT[2,2,t]*t2	+ MAT[3,2,t]*(1-m3-lat)				+ trans*MAT[3,1,t]*MAT[4,3,t]/N;
MAT[3,3,t+1] <- MAT[2,3,t]*t2	+ MAT[3,3,t]*(1-m3-madd-rec)			+ lat*MAT[3,2,t];
MAT[3,4,t+1] <- MAT[2,4,t]*t2	+ MAT[3,4,t]*(1-m3-loss)			+ rec*MAT[3,3,t];
# calcul des effectifs par ?tat de sant?
MAT[4,1,t+1] <- sum(MAT[1:3,1,t+1]); MAT[4,2,t+1] <- sum(MAT[1:3,2,t+1]); MAT[4,3,t+1] <- sum(MAT[1:3,3,t+1]); MAT[4,4,t+1] <- sum(MAT[1:3,4,t+1]);
nvinf[t+1]   <- trans*MAT[4,1,t]*MAT[4,3,t]/N
}# fin boucle temps
# sorties ponctuelles ? analyser
# XX
sortie1 <- (MAT[4,2,temps]+MAT[4,3,temps])/sum(MAT[4,,temps]) # proportion de malade (infectieux ou non) à la fin
# xx
sortie2 <- nvinf[temps] # nombre d'infection à la fin
# xx
sortie3 <- max(MAT[4,3,1:temps]) # ?effectif maximal de malades infectieux
# xx
sortie4 <- sum(nvinf[1:365]) #nombre d'infection la première année
sorties[i,1] <- sortie1;
sorties[i,2] <- sortie2;
sorties[i,3] <- sortie3;
sorties[i,4] <- sortie4;
}# fin boucle sc?narios AS
return(sorties)
} # fin fonction du mod?le
# END
ValNominale = c(100,
0.5, 0.0014, 0.00029, 0.0019,
0.0019, 0.0082, 5, 1/365, 1/365,
0.3, 1/5, 1/20, 1/100, 0.001)
scenario_initial = matrix(ValNominale, nrow=1, ncol=15)
res = modAppli(scenario_initial)
scenario_OAT = rbind(ValNominale,ValNominale,ValNominale,ValNominale,ValNominale,
ValNominale,ValNominale,ValNominale,ValNominale,ValNominale, ValNominale)
graph_oat = function(i, bornes){
scenario_OAT_i = scenario_OAT
if (bornes[1] != Inf){
inf = bornes[1]
sup = bornes[2]
scenario_OAT_i[, i] = c(ValNominale[i],
inf + (sup-inf)  * c(0, 0.01, 0.1, 0.3, 0.4, 0.5, 0.7, 0.9, 0.99, 1)
)
}
else{
scenario_OAT_i[, i] = ValNominale[i] * c(1,
0, 1/100, 1/10, 1/5, 0.9,
1.1, 2, 5, 10, 100)
}
res = modAppli(scenario_OAT_i)
fina = tibble(paramettre_i = scenario_OAT_i[, i],
prop_inf = res[,1]/res[1,1],
infec_end = res[,2]/res[1,2],
nb_max_infec = res[,3]/res[1,3] ,
nb_infec_year1 = res[,4]/res[1,4])
ggplot() +
geom_line(data = fina, aes(x = paramettre_i, y = prop_inf, color = "S1"), size = 1) +
geom_line(data = fina, aes(x = paramettre_i, y = infec_end, color = "S2"), size = 1) +
geom_line(data = fina, aes(x = paramettre_i, y = nb_max_infec,  color = "S3"), size = 1) +
geom_line(data = fina, aes(x = paramettre_i, y = nb_infec_year1,  color = "S4"), size = 1) +
scale_x_continuous(trans='log10') +
labs(x = "Parameter value", y = "Relative variation") +
theme_minimal() +
ggtitle(i)
}
graph_oat(i = 1, bornes = c(0, 500))
graph_oat(i = 1, bornes = c(Inf, Inf))
ggarrange(graph_oat(i = 1, bornes = c(Inf, Inf)), graph_oat(i = 2, bornes = c(0, 1)), graph_oat(i = 3, bornes = c(0, 1)),
graph_oat(i = 4, bornes = c(0, 1)), graph_oat(i = 4, bornes = c(0, 1)), graph_oat(i = 5, bornes = c(Inf, Inf)),
graph_oat(i = 7, bornes = c(Inf, Inf)), graph_oat(i = 8, bornes = c(Inf, Inf)), graph_oat(i = 9, bornes = c(0, 1)),
graph_oat(i = 10, bornes = c(0,1)), graph_oat(i = 11, bornes = c(0, 1)), graph_oat(i = 12, bornes = c(0, 1)),
graph_oat(i = 13, bornes = c(0, 1)), graph_oat(i = 14, bornes = c(0, 1)), graph_oat(i = 15, bornes = c(0, 1)),
ncol = 3, nrow = 5)
