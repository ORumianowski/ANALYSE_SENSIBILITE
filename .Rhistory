normaliseSortie(ValNominale)
return(sortie)
}
createMatriceForOAT <- function(ValNominale){
nbParametres = length(ValNominale)
nbScenariosParParam = 11
nbScenariosTotal = nbScenariosParParam*nbParametres
valeurMin = ValNominale * 0.75
valeurMax = ValNominale * 1.25
matrixScenario =  matrix(rep(ValNominale, each = nbScenariosTotal), nrow = nbScenariosTotal, ncol = nbParametres)
for (i in 1:nbParametres){
i_min = nbScenariosParParam*(i-1)+1
i_max = nbScenariosParParam*i
matrixScenario[i_min:i_max,i] = pracma::linspace(valeurMin[i],valeurMax[i], n = nbScenariosParParam)
}
return(matrixScenario)
}
normaliseSortie <- function(sortie,ValNominale){
sortieNominale = modAppli(matrix(ValNominale, nrow=1, ncol=15))
return(data.frame(prop_inf = sortie[,1]/sortieNominale[,1],
infec_end = sortie[,2]/sortieNominale[,2],
nb_max_infec = sortie[,3]/sortieNominale[,3],
nb_infec_year1 = sortie[,4]/sortieNominale[,4]))
}
plotOATAnalysis <- function(i,sortieNormalise,matrixScenario){
nbScenariosParParam = 11
i_min = nbScenariosParParam*(i-1)+1
i_max = nbScenariosParParam*i
resultParam_i = data.frame(parametre=matrixScenario[i_min:i_max,i],
prop_inf=sortieNormalise[i_min:i_max,1],
nb_infected_end=sortieNormalise[i_min:i_max,2],
nb_max_infec=sortieNormalise[i_min:i_max,3],
nb_infec_year1=sortieNormalise[i_min:i_max,4])
p1 = ggplot() +
geom_line(data = resultParam_i, aes(x = parametre, y = prop_inf, color = "S1"), size = 1) +
geom_line(data = resultParam_i, aes(x = parametre, y = nb_infected_end, color = "S2"), size = 1) +
geom_line(data = resultParam_i, aes(x = parametre, y = nb_max_infec,  color = "S3"), size = 1) +
geom_line(data = resultParam_i, aes(x = parametre, y = nb_infec_year1,  color = "S4"), size = 1) +
scale_x_continuous(trans='log10') +
labs(x = "Parameter value", y = "Relative variation") +
theme_minimal() +
ggtitle(par_name[i])
res_plot2 = tibble(group=rep(c("S1", "S2", "S3", "S4"), each=length(resultParam_i$prop_inf)),
value = c(resultParam_i$prop_inf,
resultParam_i$nb_infected_end,
resultParam_i$nb_max_infec,
resultParam_i$nb_infec_year1))
p2 = ggplot()+
geom_boxplot(data=res_plot2, aes(y=value, fill = group))
p3 = ggarrange(p1, p2,
ncol = 2, nrow = 1)
return(p3)
}
matriceOAT = createMatriceForOAT(ValNominale)
sortieNormalise = makeAnalyseOAT(ValNominale)
head(sortieNormalise)
plotOATAnalysis(i=1,sortieNormalise,matriceOAT)
plots <- list()
nbOfPlots <- 15
for (i in 1:nbOfPlots) {
plots[[i]] <- plotOATAnalysis(i, sortieNormalise, matriceOAT)
}
plot_grid(plotlist = plots, ncol = 1)
pi
periode = 365
w=2*pi*periode
trans =1
TRANS =1
TRANS_  = TRANS * (1 + sin(0 + w*t))
t= 1
TRANS_  = TRANS * (1 + sin(0 + w*t))
TRANS_
t= 1:20
TRANS_  = TRANS * (1 + sin(0 + w*t))
TRANS_
w
w*t
sin(0 + w*t)
(1 + sin(0 + w*t))
periode = 365
w=2*pi/periode
TRANS =1
t= 1:20
TRANS_  = TRANS * (1 + sin(0 + w*t))
TRANS_
periode = 365
w=2*pi/periode
TRANS =1
t= 1:365
TRANS_  = TRANS * (1 + sin(0 + w*t))
TRANS_
plot(t, TRANS_)
TRANS_[2]
t= 2
TRANS_  = TRANS * (1 + sin(0 + w*t))
TRANS_
trans_saisonnalité
trans_saisonnalité = function(trans, t, periode = 365){
w=2*pi/periode
trans_ = trans * (1 + sin(0 + w*t))
return(trans_)
}
trans_saisonnalité(1, 5)
trans_saisonnalité = function(trans, t, periode = 365){
w=2*pi/periode
trans_ = trans * (1 + sin(0 + w*t))
return(trans_)
}
#actualisation de la force de contagion en fonction du temps
trans_saison = mafonction(trans, t)
library(tidyverse)
modAppli_saison <- function(parametre){
# Version donn?e par les profs
# CONDITIONS DE SIMULATION
temps = 2*365; # nb de pas de temps (en jours)
# initialisation pour la sauvegarde de 4 sorties ponctuelles pour chaque jeu de param?tres
sorties <- matrix(0, nrow=nrow(parametre), ncol=4)
# boucle des sc?narios de l'?chantillonnage de l'AS
for (i in 1:nrow(parametre)) {
# STRUCTURE & PARAMETRES DU MODELE
# Parametres decrivant la population
K = parametre[i,1];		# capacite de charge
sr = parametre[i,2];	# Sex ratio
m1 = parametre[i,3];	# taux de mortalite dans la classe d'?ge 1 (enfant)
m2 = parametre[i,4];	# taux de mortalite dans la classe d'?ge 2 (adulte)
m3 = parametre[i,5];	# taux de mortalite dans la classe d'?ge 3 (senior)
f2 = parametre[i,6];	# taux de fertilite pour la classe d'age 2 (adulte)
f3 = parametre[i,7];	# taux de fertilite pour la classe d'age 3 (senior)
portee = parametre[i,8];	# nombre de portees a chaque pas de temps
t1 = parametre[i,9];	# proportion d'individus passant de la classe d'?ge 1 ? la classe d'?ge 2 ? chaque instant t
t2 = parametre[i,10];	# proportion d'individus passant de la classe d'?ge 2 ? la classe d'?ge 3 ? chaque instant t
# Parametre relatif ? la maladie
trans = parametre[i,11]; # taux de transmission
lat = parametre[i,12];	# taux de passage de l'etat latent a l'etat infecte
rec = parametre[i,13];	# taux de recuperation
loss = parametre[i,14];	# taux de perte d'immunite
madd = parametre[i,15];	# taux de mortalite du a la maladie
#Prise en compte de la saisonnalité de la force de contagion
trans_saisonnalité = function(trans, t, periode = 365){
w=2*pi/periode
trans_ = trans * (1 + sin(0 + w*t))
return(trans_)
}
# INITIALISATION
MAT <- array(0, dim=c(4,4,temps)); # nb indiv par classe d'?ge en ligne (derni?re ligne = pop tot), ?tat de sant? en colonne, pas de temps (dimension 3)
nvinf <- array(0, dim=c(temps));
# conditions initiales (la population est ? sa structure d'?quilibre, calcul?e par ailleurs)
MAT[1,1,1] <- 27; # nombre d'enfants sains
MAT[2,1,1] <- 23; # nombre d'adulte sains
MAT[3,1,1] <- 36; # nombre de seniors sains
MAT[3,3,1] <- 1;  # nombre de seniors infectes
# effectifs par ?tat de sant?
MAT[4,1,1] <- sum(MAT[1:3,1,1]); MAT[4,2,1] <- sum(MAT[1:3,2,1]); MAT[4,3,1] <- sum(MAT[1:3,3,1]); MAT[4,4,1] <- sum(MAT[1:3,4,1]);
# SIMULATIONS
# boucle du temps
for (t in 1:(temps-1)) {
#actualisation de la force de contagion en fonction du temps
trans_saison = trans_saisonnalité(trans, t)
# classe d'?ge 1 : Enfant (non mature pour la reproduction)
# RQ : les naissances sont XX, les nouveaux n?s ?tant dans l'?tat susceptible
N <- sum(MAT[4,,t]);	# taille de la pop en t
MAT[1,1,t+1] <- MAT[1,1,t]*(1-m1-t1-trans_saison*MAT[4,3,t]/N) + loss*MAT[1,4,t]      + max(0, sr*portee*(sum(MAT[2,,t])*f2 + sum(MAT[3,,t])*f3) * (1 - N/K));
MAT[1,2,t+1] <- MAT[1,2,t]*(1-m1-t1-lat)			  + trans_saison*MAT[1,1,t]*MAT[4,3,t]/N;
MAT[1,3,t+1] <- MAT[1,3,t]*(1-m1-madd-t1-rec)  		  + lat*MAT[1,2,t];
MAT[1,4,t+1] <- MAT[1,4,t]*(1-m1-t1-loss) 		  + rec*MAT[1,3,t];
# classe d'?ge 2 : Adulte
MAT[2,1,t+1] <- MAT[1,1,t]*t1	+ MAT[2,1,t]*(1-m2-t2-trans_saison*MAT[4,3,t]/N) + loss*MAT[2,4,t];
MAT[2,2,t+1] <- MAT[1,2,t]*t1	+ MAT[2,2,t]*(1-m2-t2-lat)			+ trans_saison*MAT[2,1,t]*MAT[4,3,t]/N;
MAT[2,3,t+1] <- MAT[1,3,t]*t1	+ MAT[2,3,t]*(1-m2-madd-t2-rec)		+ lat*MAT[2,2,t];
MAT[2,4,t+1] <- MAT[1,4,t]*t1	+ MAT[2,4,t]*(1-m2-t2-loss)			+ rec*MAT[2,3,t];
# classe d'?ge 3 : Senior
MAT[3,1,t+1] <- MAT[2,1,t]*t2	+ MAT[3,1,t]*(1-m3-trans_saison*MAT[4,3,t]/N) 	+ loss*MAT[3,4,t];
MAT[3,2,t+1] <- MAT[2,2,t]*t2	+ MAT[3,2,t]*(1-m3-lat)				+ trans_saison*MAT[3,1,t]*MAT[4,3,t]/N;
MAT[3,3,t+1] <- MAT[2,3,t]*t2	+ MAT[3,3,t]*(1-m3-madd-rec)			+ lat*MAT[3,2,t];
MAT[3,4,t+1] <- MAT[2,4,t]*t2	+ MAT[3,4,t]*(1-m3-loss)			+ rec*MAT[3,3,t];
# calcul des effectifs par ?tat de sant?
MAT[4,1,t+1] <- sum(MAT[1:3,1,t+1]); MAT[4,2,t+1] <- sum(MAT[1:3,2,t+1]); MAT[4,3,t+1] <- sum(MAT[1:3,3,t+1]); MAT[4,4,t+1] <- sum(MAT[1:3,4,t+1]);
nvinf[t+1]   <- trans_saison*MAT[4,1,t]*MAT[4,3,t]/N
}# fin boucle temps
# sorties ponctuelles ? analyser
# XX
sortie1 <- (MAT[4,2,temps]+MAT[4,3,temps])/sum(MAT[4,,temps])
# xx
sortie2 <- nvinf[temps]
# xx
sortie3 <- max(MAT[4,3,1:temps])
# xx
sortie4 <- sum(nvinf[1:365])
sorties[i,1] <- sortie1;
sorties[i,2] <- sortie2;
sorties[i,3] <- sortie3;
sorties[i,4] <- sortie4;
}# fin boucle sc?narios AS
return(sorties)
} # fin fonction du mod?le
# END
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggpubr)
library(sensitivity)
library(dplyr)
library(cowplot)
source(file = "functionModProjet2023_with_seasonality.r")
library(tidyverse)
library(ggpubr)
library(sensitivity)
library(dplyr)
library(cowplot)
source(file = "functionModProjet2023 _with_seasonality.r")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggpubr)
library(sensitivity)
library(dplyr)
library(cowplot)
source(file = "functionModProjet2023_with_seasonality.r")
ValNominale = c(100, 0.5, 0.0014, 0.00029, 0.0019,
0.0019, 0.0082, 5, 1/365, 1/365,
0.3, 1/5, 1/20, 1/100, 0.001)
scenario_initial = matrix(ValNominale, nrow=1, ncol=15)
res = modAppli1(scenario_initial)
effectif_data = tibble(
temps = 1:(2*365),
S = res[[2]][4,1,],
L = res[[2]][4,2,],
I = res[[2]][4,3,],
R = res[[2]][4,4,],
N = S + L + I + R,
C1 = res[[2]][1,1,] + res[[2]][1,2,] + res[[2]][1,3,] + res[[2]][1,4,],
C2 = res[[2]][2,1,] + res[[2]][2,2,] + res[[2]][2,3,] + res[[2]][2,4,],
C3 = res[[2]][3,1,] + res[[2]][3,2,] + res[[2]][3,3,] + res[[2]][3,4,]
)
p1 = ggplot() +
geom_line(data = effectif_data, aes(x = temps, y = S, color = "1- Susceptible"), linewidth = 1) +
geom_line(data = effectif_data, aes(x = temps, y = L, color = "2- Latent"), linewidth = 1) +
geom_line(data = effectif_data, aes(x = temps, y = I, color = "3- Infectious"), linewidth = 1) +
geom_line(data = effectif_data, aes(x = temps, y = R, color = "4- Recovered"), linewidth = 1) +
geom_line(data = effectif_data, aes(x = temps, y = N, color = "Population Size"), linewidth = 1) +
labs(x = "Time", y = "Effectif") +
theme_minimal() +
ggtitle("Evolution of Epidemic stages - Initial Model")
effectif_data2 <- tibble(effectif =
c(effectif_data$C1,
effectif_data$C2,
effectif_data$C3),
temps = rep(effectif_data$temps, times = 3))  %>%
mutate(age_class = rep(c("First Age Class", "Second Age Class", "Third Age Class"), each = nrow(effectif_data) )) %>%
group_by(temps, age_class) %>%
summarise(n = sum(effectif)) %>%
mutate(percentage = n / sum(n))
p2 = ggplot(effectif_data2, aes(x=temps, y=percentage, fill=age_class)) +
geom_area(alpha=0.4 , size=1, colour="black")+
labs(fill = "Age class") +
labs(x = "Time", y = "Effectif") +
theme_minimal() +
ggtitle("Evolution of age structure - Initial Model")
p1
p2
par_name = c("K", "sr", "m1", "m2", "m3", "f2", "f3", "portee", "t1", "t2", "trans", "lat", "rec", "loss", "madd")
ValNominale = c(100,
0.5, 0.0014, 0.00029, 0.0019,
0.0019, 0.0082, 5, 1/365, 1/365,
0.3, 1/5, 1/20, 1/100, 0.001)
makeAnalyseOAT <- function(ValNominale){
sortie = createMatriceForOAT(ValNominale) %>%
modAppli() %>%
normaliseSortie(ValNominale)
return(sortie)
}
createMatriceForOAT <- function(ValNominale){
nbParametres = length(ValNominale)
nbScenariosParParam = 11
nbScenariosTotal = nbScenariosParParam*nbParametres
valeurMin = ValNominale * 0.75
valeurMax = ValNominale * 1.25
matrixScenario =  matrix(rep(ValNominale, each = nbScenariosTotal), nrow = nbScenariosTotal, ncol = nbParametres)
for (i in 1:nbParametres){
i_min = nbScenariosParParam*(i-1)+1
i_max = nbScenariosParParam*i
matrixScenario[i_min:i_max,i] = pracma::linspace(valeurMin[i],valeurMax[i], n = nbScenariosParParam)
}
return(matrixScenario)
}
normaliseSortie <- function(sortie,ValNominale){
sortieNominale = modAppli(matrix(ValNominale, nrow=1, ncol=15))
return(data.frame(prop_inf = sortie[,1]/sortieNominale[,1],
infec_end = sortie[,2]/sortieNominale[,2],
nb_max_infec = sortie[,3]/sortieNominale[,3],
nb_infec_year1 = sortie[,4]/sortieNominale[,4]))
}
plotOATAnalysis <- function(i,sortieNormalise,matrixScenario){
nbScenariosParParam = 11
i_min = nbScenariosParParam*(i-1)+1
i_max = nbScenariosParParam*i
resultParam_i = data.frame(parametre=matrixScenario[i_min:i_max,i],
prop_inf=sortieNormalise[i_min:i_max,1],
nb_infected_end=sortieNormalise[i_min:i_max,2],
nb_max_infec=sortieNormalise[i_min:i_max,3],
nb_infec_year1=sortieNormalise[i_min:i_max,4])
p1 = ggplot() +
geom_line(data = resultParam_i, aes(x = parametre, y = prop_inf, color = "S1"), size = 1) +
geom_line(data = resultParam_i, aes(x = parametre, y = nb_infected_end, color = "S2"), size = 1) +
geom_line(data = resultParam_i, aes(x = parametre, y = nb_max_infec,  color = "S3"), size = 1) +
geom_line(data = resultParam_i, aes(x = parametre, y = nb_infec_year1,  color = "S4"), size = 1) +
scale_x_continuous(trans='log10') +
labs(x = "Parameter value", y = "Relative variation") +
theme_minimal() +
ggtitle(par_name[i])
res_plot2 = tibble(group=rep(c("S1", "S2", "S3", "S4"), each=length(resultParam_i$prop_inf)),
value = c(resultParam_i$prop_inf,
resultParam_i$nb_infected_end,
resultParam_i$nb_max_infec,
resultParam_i$nb_infec_year1))
p2 = ggplot()+
geom_boxplot(data=res_plot2, aes(y=value, fill = group))
p3 = ggarrange(p1, p2,
ncol = 2, nrow = 1)
return(p3)
}
matriceOAT = createMatriceForOAT(ValNominale)
sortieNormalise = makeAnalyseOAT(ValNominale)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggpubr)
library(sensitivity)
library(dplyr)
library(cowplot)
source(file = "functionModProjet2023_with_seasonality.r")
ValNominale = c(100, 0.5, 0.0014, 0.00029, 0.0019,
0.0019, 0.0082, 5, 1/365, 1/365,
0.3, 1/5, 1/20, 1/100, 0.001)
scenario_initial = matrix(ValNominale, nrow=1, ncol=15)
res = modAppli1(scenario_initial)
effectif_data = tibble(
temps = 1:(2*365),
S = res[[2]][4,1,],
L = res[[2]][4,2,],
I = res[[2]][4,3,],
R = res[[2]][4,4,],
N = S + L + I + R,
C1 = res[[2]][1,1,] + res[[2]][1,2,] + res[[2]][1,3,] + res[[2]][1,4,],
C2 = res[[2]][2,1,] + res[[2]][2,2,] + res[[2]][2,3,] + res[[2]][2,4,],
C3 = res[[2]][3,1,] + res[[2]][3,2,] + res[[2]][3,3,] + res[[2]][3,4,]
)
p1 = ggplot() +
geom_line(data = effectif_data, aes(x = temps, y = S, color = "1- Susceptible"), linewidth = 1) +
geom_line(data = effectif_data, aes(x = temps, y = L, color = "2- Latent"), linewidth = 1) +
geom_line(data = effectif_data, aes(x = temps, y = I, color = "3- Infectious"), linewidth = 1) +
geom_line(data = effectif_data, aes(x = temps, y = R, color = "4- Recovered"), linewidth = 1) +
geom_line(data = effectif_data, aes(x = temps, y = N, color = "Population Size"), linewidth = 1) +
labs(x = "Time", y = "Effectif") +
theme_minimal() +
ggtitle("Evolution of Epidemic stages - Initial Model")
effectif_data2 <- tibble(effectif =
c(effectif_data$C1,
effectif_data$C2,
effectif_data$C3),
temps = rep(effectif_data$temps, times = 3))  %>%
mutate(age_class = rep(c("First Age Class", "Second Age Class", "Third Age Class"), each = nrow(effectif_data) )) %>%
group_by(temps, age_class) %>%
summarise(n = sum(effectif)) %>%
mutate(percentage = n / sum(n))
p2 = ggplot(effectif_data2, aes(x=temps, y=percentage, fill=age_class)) +
geom_area(alpha=0.4 , size=1, colour="black")+
labs(fill = "Age class") +
labs(x = "Time", y = "Effectif") +
theme_minimal() +
ggtitle("Evolution of age structure - Initial Model")
p1
p2
par_name = c("K", "sr", "m1", "m2", "m3", "f2", "f3", "portee", "t1", "t2", "trans", "lat", "rec", "loss", "madd")
ValNominale = c(100,
0.5, 0.0014, 0.00029, 0.0019,
0.0019, 0.0082, 5, 1/365, 1/365,
0.3, 1/5, 1/20, 1/100, 0.001)
makeAnalyseOAT <- function(ValNominale){
sortie = createMatriceForOAT(ValNominale) %>%
modAppli() %>%
normaliseSortie(ValNominale)
return(sortie)
}
createMatriceForOAT <- function(ValNominale){
nbParametres = length(ValNominale)
nbScenariosParParam = 11
nbScenariosTotal = nbScenariosParParam*nbParametres
valeurMin = ValNominale * 0.75
valeurMax = ValNominale * 1.25
matrixScenario =  matrix(rep(ValNominale, each = nbScenariosTotal), nrow = nbScenariosTotal, ncol = nbParametres)
for (i in 1:nbParametres){
i_min = nbScenariosParParam*(i-1)+1
i_max = nbScenariosParParam*i
matrixScenario[i_min:i_max,i] = pracma::linspace(valeurMin[i],valeurMax[i], n = nbScenariosParParam)
}
return(matrixScenario)
}
normaliseSortie <- function(sortie,ValNominale){
sortieNominale = modAppli(matrix(ValNominale, nrow=1, ncol=15))
return(data.frame(prop_inf = sortie[,1]/sortieNominale[,1],
infec_end = sortie[,2]/sortieNominale[,2],
nb_max_infec = sortie[,3]/sortieNominale[,3],
nb_infec_year1 = sortie[,4]/sortieNominale[,4]))
}
plotOATAnalysis <- function(i,sortieNormalise,matrixScenario){
nbScenariosParParam = 11
i_min = nbScenariosParParam*(i-1)+1
i_max = nbScenariosParParam*i
resultParam_i = data.frame(parametre=matrixScenario[i_min:i_max,i],
prop_inf=sortieNormalise[i_min:i_max,1],
nb_infected_end=sortieNormalise[i_min:i_max,2],
nb_max_infec=sortieNormalise[i_min:i_max,3],
nb_infec_year1=sortieNormalise[i_min:i_max,4])
p1 = ggplot() +
geom_line(data = resultParam_i, aes(x = parametre, y = prop_inf, color = "S1"), size = 1) +
geom_line(data = resultParam_i, aes(x = parametre, y = nb_infected_end, color = "S2"), size = 1) +
geom_line(data = resultParam_i, aes(x = parametre, y = nb_max_infec,  color = "S3"), size = 1) +
geom_line(data = resultParam_i, aes(x = parametre, y = nb_infec_year1,  color = "S4"), size = 1) +
scale_x_continuous(trans='log10') +
labs(x = "Parameter value", y = "Relative variation") +
theme_minimal() +
ggtitle(par_name[i])
res_plot2 = tibble(group=rep(c("S1", "S2", "S3", "S4"), each=length(resultParam_i$prop_inf)),
value = c(resultParam_i$prop_inf,
resultParam_i$nb_infected_end,
resultParam_i$nb_max_infec,
resultParam_i$nb_infec_year1))
p2 = ggplot()+
geom_boxplot(data=res_plot2, aes(y=value, fill = group))
p3 = ggarrange(p1, p2,
ncol = 2, nrow = 1)
return(p3)
}
matriceOAT = createMatriceForOAT(ValNominale)
sortieNormalise = makeAnalyseOAT(ValNominale)
head(sortieNormalise)
plotOATAnalysis(i=1,sortieNormalise,matriceOAT)
plots <- list()
nbOfPlots <- 15
for (i in 1:nbOfPlots) {
plots[[i]] <- plotOATAnalysis(i, sortieNormalise, matriceOAT)
}
plot_grid(plotlist = plots, ncol = 1)
par_name = c("K", "sr", "m1", "m2", "m3", "f2", "f3", "portee", "t1", "t2", "trans", "lat", "rec", "loss", "madd")
lowerValues = ValNominale*.75
upperValues = ValNominale*1.25
# On utilise la fonction Morris du package sensitivity
Morris <- morris(model = modAppli,
factors = par_name,
r = 50,
scale=TRUE,
design = list(type = "oat", levels = 6, grid.jump = 3),
binf=lowerValues,
bsup=upperValues)
par_name = c("K", "sr", "m1", "m2", "m3", "f2", "f3", "portee", "t1", "t2", "trans", "lat", "rec", "loss", "madd")
lowerValues = ValNominale*.75
upperValues = ValNominale*1.25
# On utilise la fonction Morris du package sensitivity
Morris <- morris(model = modAppli,
factors = par_name,
r = 50,
scale=TRUE,
design = list(type = "oat", levels = 6, grid.jump = 3),
binf=lowerValues,
bsup=upperValues)
get_dfMorris <- function(Morris){
# Cette fonction sert à récupérer mu, mu* et sigma pour chaque sortie du modèle sous
# la forme d'un data frame
dfMorris = getMorrisResult(Morris$ee,mean,"mu") %>%
cbind(getMorrisResult(abs(Morris$ee),mean,"mu.star")) %>% # mu.star mesure la sensibilité
cbind(getMorrisResult(Morris$ee,sd,"sigma")) # sigma mesure interactions et relations non linéaires
return(dfMorris)
}
getMorrisResult <- function(Morris_ee, functionToApply,parameter){
# Sous fonction de get_dfMorris pour calculer mu, mu* ou sigma
# en appliquant la methode donnée dans l'aide de la fonction morris
df = apply(Morris_ee, 3, function(M){apply(M, 2, functionToApply)}) %>%
as.data.frame() %>%
renameColMorris(parameter)
}
renameColMorris <- function(df,parameter){
# Sous fonction de getMorrisResult, sert à avoir des noms
# de colonnes qui font sens
colnames(df) <- paste0(parameter, "_S", 1:4)
return(df)
}
plotMorris <- function(mu.star_SX,sigma_SX,title="Analyse de Morris",parametersList=par_name){
Parametres <- c(rep("démographiques",10),rep("épidémiques",5))
plot <- ggplot(data=NULL,aes(x=mu.star_SX,y=sigma_SX,col=Parametres)) +
geom_text(aes(label=parametersList),size=2) +
scale_color_manual(values = c("darkblue","darkred")) +
xlab(label="mu*") +
ylab(label="sigma") +
labs(title = title) +
theme_minimal()+
theme(text = element_text(size = 6))
return(plot)
}
dfMorris <- get_dfMorris(Morris)
plot_S1 <- plotMorris(mu.star_SX=dfMorris$mu.star_S1,sigma_SX=dfMorris$sigma_S1,
title="Sortie : Nombre d'infectés le dernier jour")
plot_S2 <- plotMorris(mu.star_SX=dfMorris$mu.star_S2,sigma_SX=dfMorris$sigma_S2,
title="Sortie : Nombre d'infection le dernier jour")
plot_S3 <- plotMorris(mu.star_SX=dfMorris$mu.star_S3,sigma_SX=dfMorris$sigma_S3,
title="Sortie : Nombre d'infectés sur les 2 annnées")
plot_S4 <- plotMorris(mu.star_SX=dfMorris$mu.star_S4,sigma_SX=dfMorris$sigma_S4,
title = "Sortie : Nombre d'infection la première année")
grid <- plot_grid(plotlist = list(plot_S1,plot_S2,plot_S3,plot_S4),ncol=2)
plot_grid(
ggdraw() + draw_text("Analyse de Morris", x = 0.5, y = 1, vjust = 2, hjust = 0.5, size = 16),
grid,
ncol = 1,
rel_heights = c(0.1, 1)
)
