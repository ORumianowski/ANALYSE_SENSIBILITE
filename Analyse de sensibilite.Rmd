---
title: "Analyse sensibilité"
author: "RUMIANOWSKI 0."
output: 
  html_document:
    theme: simplex
date: "2023-09-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Question 1

#### 1.A.
  
  Le modèle est déterministe, à compartiment et à un temps discret
  
#### 1.B. 
  
  Le processus biologique modélisé est une épidémie.
  
  Les individus sont groupés en quatre catégories selon le stade épidémique:  
  
  1- les individus sensibles, notés S, sont susceptibles de contracter la maladie
  
  2- les individus infectés/non-infectieux, noté L, sont infectés sans être contagieux, ils ont à un stade latent
  
  3- les individus infectés/infectieux, noté I, sont infectés, contagieux et symptomatique. Ils sont soumis à un risque de mortalité additionnel spécifique à la maladie.
  
  4- les individus rétablis/non-sensible, noté R, ne sont plus contagieux, présentent plus de symptomes et ne peuvent plus être infectés.
  
  En plus du stade épidémique, la structure d'âge de la population est prise en compte. 
  Chaque individu est associé à une classe d'âge avec une mortalité intrasèque spécifique.
  La structure d'âge est décrite avec trois classes où les seuls les individus de la 2e et la 3e classe se reproduisent selon une fécondité spécifique à l'âge.
 
  
#### 1.C.
  
  FORMULE EN LATEX (si tu es chaud en LATEX, n'hésite pas !)
  
  
#### 1.D.
  
  ![Texte alternatif](image/transition_stade_epidemie.png){width=50%}
  ![Texte alternatif](image/transition_classe_age.png){width=50%}
  
  
#### 1.E.
  
  Les hypothèses de modèle 
  
  dynamique des population
  dynamique épidémiologique
  
#### 1.F.
  
  Les conditions initiales du modèle sont :
    27 individus sensibles de classe d'âge 1
    23 individus sensibles de classe d'âge 1
    36 individus sensibles de classe d'âge 3
    1 individus infecté et infectieux de classe d'âge 3
  
#### 1.G.
  
  Les sorties proposés sont :
  
  1- la proportion de malades i.e. infectés (infectieux ou non) à la fin de la période d'étude (deux ans)
  
  2- le nombre d'infection réalisées le dernier jour de la période d'étude
  
  3- le nombre maximum de d'infectés pendant la période d'étude
  
  4- le nombre d'infection réalisés pendant la première année de l'étude
  
  D'autres sorties possibles du modèle peuvent être :
  
  5- la proportion maximale de malades pendant la période d'étude
  
  6- le nombre d'individus sensibles à la fin de la période d'étude
  
#### 1.H.
  
  K : Capacité de l'environnment. Valeur au-dessus de laquelle la population ne produit plus de portée.
  sr : Sex-ratio (proportion de femelles)
  portee : taille des portées
  m_i : mortalité intrasèque spécifique à la classe i
  f_i : fécondité de la classe i
  t_i : probabilité de partir de la classe d'âge i pour rentrer dans la classe i+1
  
  trans : probabilité d'infection (quitter le groupe des sensibles pour devenir infecté/non-infectieux)
  lat : probabilité de devenir contagieux (quitter le groupe des infectés/non-infectieux pour devenir infectés/infectieux)
  rect: probabilité de guérir (quitter le groupe des infectés/infectieux pour devenir guéri/non-sensible)
  loss : probalitité de perte d'immunité (quitter le groupe des guéri/non-sensible pour redevenir sensible)
  
  madd : probabilité de mourir pendant le stade infectés/infectieux
  
#### 1.I.

```{r, warning=FALSE, message=FALSE, echo=FALSE}
library(tidyverse)


### Mod?le dont la sensibilit? doit ?tre analys?e dans le cadre du projet MODE-MPI 2023-2024

### Le mod?le est ici d?fini sous forme de fonction pour faciliter vos analyses de sensibilit? (AS)
### La fonction renvoie les sorties ponctuelles qui sont ? analyser dans l'AS

modAppli <- function(parametre){  

  # CONDITIONS DE SIMULATION
  temps = 2*365; # nb de pas de temps (en jours)
  # initialisation pour la sauvegarde de 4 sorties ponctuelles pour chaque jeu de param?tres
  sorties <- matrix(0, nrow=nrow(parametre), ncol=4)

  # boucle des sc?narios de l'?chantillonnage de l'AS
  for (i in 1:nrow(parametre)) { 

    # STRUCTURE & PARAMETRES DU MODELE

    # XX
    K = parametre[i,1] ;		# xx
    sr = parametre[i,2] ;	# xx
    m1 = parametre[i,3] ;	# xx
    m2 = parametre[i,4] ;	# xx
    m3 = parametre[i,5] ;	# xx
    f2 = parametre[i,6] ;	# xx
    f3 = parametre[i,7] ;	# xx
    portee = parametre[i,8] ;	# xx
    t1 = parametre[i,9] ;	# xx
    t2 = parametre[i,10] ;	# xx

    # XX
    trans = parametre[i,11] ; # xx
    lat = parametre[i,12] ;	# xx
    rec = parametre[i,13] ;	# xx
    loss = parametre[i,14] ;	# xx
    madd = parametre[i,15] ;	# xx

    # INITIALISATION
    MAT <- array(0, dim=c(4,4,temps)); # nb indiv par classe d'?ge en ligne (derni?re ligne = pop tot), ?tat de sant? en colonne, pas de temps (dimension 3)
    nvinf <- array(0, dim=c(temps));
    # conditions initiales (la population est ? sa structure d'?quilibre, calcul?e par ailleurs)
    MAT[1,1,1] <- 27; # xx
    MAT[2,1,1] <- 23; # xx
    MAT[3,1,1] <- 36; # xx
    MAT[3,3,1] <- 1;  # xx
    # effectifs par ?tat de sant?
    MAT[4,1,1] <- sum(MAT[1:3,1,1]); MAT[4,2,1] <- sum(MAT[1:3,2,1]); MAT[4,3,1] <- sum(MAT[1:3,3,1]); MAT[4,4,1] <- sum(MAT[1:3,4,1]);

    # SIMULATIONS
    # boucle du temps
    for (t in 1:(temps-1)) { 
     # classe d'?ge xx
      # RQ : les naissances sont XX, les nouveaux n?s ?tant dans l'?tat XX
      N <- sum(MAT[4,,t]);	# taille de la pop en t
	MAT[1,1,t+1] <- MAT[1,1,t]*(1-m1-t1-trans*MAT[4,3,t]/N) + loss*MAT[1,4,t]      + max(0, sr*portee*(sum(MAT[2,,t])*f2 + sum(MAT[3,,t])*f3) * (1 - N/K)); 
	MAT[1,2,t+1] <- MAT[1,2,t]*(1-m1-t1-lat)			  + trans*MAT[1,1,t]*MAT[4,3,t]/N; 
	MAT[1,3,t+1] <- MAT[1,3,t]*(1-m1-madd-t1-rec)  		  + lat*MAT[1,2,t]; 
	MAT[1,4,t+1] <- MAT[1,4,t]*(1-m1-t1-loss) 		  + rec*MAT[1,3,t]; 
     # classe d'?ge xx
	MAT[2,1,t+1] <- MAT[1,1,t]*t1	+ MAT[2,1,t]*(1-m2-t2-trans*MAT[4,3,t]/N) + loss*MAT[2,4,t];
	MAT[2,2,t+1] <- MAT[1,2,t]*t1	+ MAT[2,2,t]*(1-m2-t2-lat)			+ trans*MAT[2,1,t]*MAT[4,3,t]/N;
	MAT[2,3,t+1] <- MAT[1,3,t]*t1	+ MAT[2,3,t]*(1-m2-madd-t2-rec)		+ lat*MAT[2,2,t];
	MAT[2,4,t+1] <- MAT[1,4,t]*t1	+ MAT[2,4,t]*(1-m2-t2-loss)			+ rec*MAT[2,3,t];
     # classe d'?ge xx
	MAT[3,1,t+1] <- MAT[2,1,t]*t2	+ MAT[3,1,t]*(1-m3-trans*MAT[4,3,t]/N) 	+ loss*MAT[3,4,t];
	MAT[3,2,t+1] <- MAT[2,2,t]*t2	+ MAT[3,2,t]*(1-m3-lat)				+ trans*MAT[3,1,t]*MAT[4,3,t]/N;
	MAT[3,3,t+1] <- MAT[2,3,t]*t2	+ MAT[3,3,t]*(1-m3-madd-rec)			+ lat*MAT[3,2,t];
	MAT[3,4,t+1] <- MAT[2,4,t]*t2	+ MAT[3,4,t]*(1-m3-loss)			+ rec*MAT[3,3,t];
     # calcul des effectifs par ?tat de sant?
	MAT[4,1,t+1] <- sum(MAT[1:3,1,t+1]); MAT[4,2,t+1] <- sum(MAT[1:3,2,t+1]); MAT[4,3,t+1] <- sum(MAT[1:3,3,t+1]); MAT[4,4,t+1] <- sum(MAT[1:3,4,t+1]);
	nvinf[t+1]   <- trans*MAT[4,1,t]*MAT[4,3,t]/N

    }# fin boucle temps

    # sorties ponctuelles ? analyser
    # XX
    sortie1 <- (MAT[4,2,temps]+MAT[4,3,temps])/sum(MAT[4,,temps]) # proportion de malade (infectieux ou non) à la fin
    # xx
    sortie2 <- nvinf[temps] # nombre d'infection à la fin
    # xx
    sortie3 <- max(MAT[4,3,1:temps]) # ?effectif maximal de malades infectieux
    # xx
    sortie4 <- sum(nvinf[1:365]) #nombre d'infection la première année
    
    sorties[i,1] <- sortie1;
    sorties[i,2] <- sortie2;
    sorties[i,3] <- sortie3;
    sorties[i,4] <- sortie4;
    
  }# fin boucle sc?narios AS
  
  res = list(sorties, MAT, nvinf)
  
  return(res)
} # fin fonction du mod?le

# END



ValNominale = c(100, 0.5, 0.0014, 0.00029, 0.0019, 
                0.0019, 0.0082, 5, 1/365, 1/365, 
                0.3, 1/5, 1/20, 1/100, 0.001)


scenario_initial = matrix(ValNominale, nrow=1, ncol=15)

res = modAppli(scenario_initial)


effectif = tibble(
       temps = 1:(2*365),
       S = res[[2]][4,1,],
       L = res[[2]][4,2,],
       I = res[[2]][4,3,],
       R = res[[2]][4,4,],
       
       N = S + L + I + R)


ggplot() +
  geom_line(data = effectif, aes(x = temps, y = S, color = "1- Susceptible"), linewidth = 1) +
  geom_line(data = effectif, aes(x = temps, y = L, color = "2- Latent"), linewidth = 1) +
  geom_line(data = effectif, aes(x = temps, y = I, color = "3- Infectious"), linewidth = 1) +
  geom_line(data = effectif, aes(x = temps, y = R, color = "4- Recovered"), linewidth = 1) +
  geom_line(data = effectif, aes(x = temps, y = N, color = "Population Size"), linewidth = 1) +
  labs(x = "Time", y = "Population") +
  theme_minimal() +
  ggtitle("Initial Model")

```

  
#### 2.A

```{r, warning=FALSE, message=FALSE, echo=FALSE}
library(tidyverse)
library(ggpubr)


### Mod?le dont la sensibilit? doit ?tre analys?e dans le cadre du projet MODE-MPI 2023-2024

### Le mod?le est ici d?fini sous forme de fonction pour faciliter vos analyses de sensibilit? (AS)
### La fonction renvoie les sorties ponctuelles qui sont ? analyser dans l'AS

modAppli <- function(parametre){  

  # CONDITIONS DE SIMULATION
  temps = 2*365; # nb de pas de temps (en jours)
  # initialisation pour la sauvegarde de 4 sorties ponctuelles pour chaque jeu de param?tres
  sorties <- matrix(0, nrow=nrow(parametre), ncol=4)

  # boucle des sc?narios de l'?chantillonnage de l'AS
  for (i in 1:nrow(parametre)) { 

    # STRUCTURE & PARAMETRES DU MODELE

    # XX
    K = parametre[i,1] ;		# xx
    sr = parametre[i,2] ;	# xx
    m1 = parametre[i,3] ;	# xx
    m2 = parametre[i,4] ;	# xx
    m3 = parametre[i,5] ;	# xx
    f2 = parametre[i,6] ;	# xx
    f3 = parametre[i,7] ;	# xx
    portee = parametre[i,8] ;	# xx
    t1 = parametre[i,9] ;	# xx
    t2 = parametre[i,10] ;	# xx

    # XX
    trans = parametre[i,11] ; # xx
    lat = parametre[i,12] ;	# xx
    rec = parametre[i,13] ;	# xx
    loss = parametre[i,14] ;	# xx
    madd = parametre[i,15] ;	# xx

    # INITIALISATION
    MAT <- array(0, dim=c(4,4,temps)); # nb indiv par classe d'?ge en ligne (derni?re ligne = pop tot), ?tat de sant? en colonne, pas de temps (dimension 3)
    nvinf <- array(0, dim=c(temps));
    # conditions initiales (la population est ? sa structure d'?quilibre, calcul?e par ailleurs)
    MAT[1,1,1] <- 27; # xx
    MAT[2,1,1] <- 23; # xx
    MAT[3,1,1] <- 36; # xx
    MAT[3,3,1] <- 1;  # xx
    # effectifs par ?tat de sant?
    MAT[4,1,1] <- sum(MAT[1:3,1,1]); MAT[4,2,1] <- sum(MAT[1:3,2,1]); MAT[4,3,1] <- sum(MAT[1:3,3,1]); MAT[4,4,1] <- sum(MAT[1:3,4,1]);

    # SIMULATIONS
    # boucle du temps
    for (t in 1:(temps-1)) { 
     # classe d'?ge xx
      # RQ : les naissances sont XX, les nouveaux n?s ?tant dans l'?tat XX
      N <- sum(MAT[4,,t]);	# taille de la pop en t
	MAT[1,1,t+1] <- MAT[1,1,t]*(1-m1-t1-trans*MAT[4,3,t]/N) + loss*MAT[1,4,t]      + max(0, sr*portee*(sum(MAT[2,,t])*f2 + sum(MAT[3,,t])*f3) * (1 - N/K)); 
	MAT[1,2,t+1] <- MAT[1,2,t]*(1-m1-t1-lat)			  + trans*MAT[1,1,t]*MAT[4,3,t]/N; 
	MAT[1,3,t+1] <- MAT[1,3,t]*(1-m1-madd-t1-rec)  		  + lat*MAT[1,2,t]; 
	MAT[1,4,t+1] <- MAT[1,4,t]*(1-m1-t1-loss) 		  + rec*MAT[1,3,t]; 
     # classe d'?ge xx
	MAT[2,1,t+1] <- MAT[1,1,t]*t1	+ MAT[2,1,t]*(1-m2-t2-trans*MAT[4,3,t]/N) + loss*MAT[2,4,t];
	MAT[2,2,t+1] <- MAT[1,2,t]*t1	+ MAT[2,2,t]*(1-m2-t2-lat)			+ trans*MAT[2,1,t]*MAT[4,3,t]/N;
	MAT[2,3,t+1] <- MAT[1,3,t]*t1	+ MAT[2,3,t]*(1-m2-madd-t2-rec)		+ lat*MAT[2,2,t];
	MAT[2,4,t+1] <- MAT[1,4,t]*t1	+ MAT[2,4,t]*(1-m2-t2-loss)			+ rec*MAT[2,3,t];
     # classe d'?ge xx
	MAT[3,1,t+1] <- MAT[2,1,t]*t2	+ MAT[3,1,t]*(1-m3-trans*MAT[4,3,t]/N) 	+ loss*MAT[3,4,t];
	MAT[3,2,t+1] <- MAT[2,2,t]*t2	+ MAT[3,2,t]*(1-m3-lat)				+ trans*MAT[3,1,t]*MAT[4,3,t]/N;
	MAT[3,3,t+1] <- MAT[2,3,t]*t2	+ MAT[3,3,t]*(1-m3-madd-rec)			+ lat*MAT[3,2,t];
	MAT[3,4,t+1] <- MAT[2,4,t]*t2	+ MAT[3,4,t]*(1-m3-loss)			+ rec*MAT[3,3,t];
     # calcul des effectifs par ?tat de sant?
	MAT[4,1,t+1] <- sum(MAT[1:3,1,t+1]); MAT[4,2,t+1] <- sum(MAT[1:3,2,t+1]); MAT[4,3,t+1] <- sum(MAT[1:3,3,t+1]); MAT[4,4,t+1] <- sum(MAT[1:3,4,t+1]);
	nvinf[t+1]   <- trans*MAT[4,1,t]*MAT[4,3,t]/N

    }# fin boucle temps

    # sorties ponctuelles ? analyser
    # XX
    sortie1 <- (MAT[4,2,temps]+MAT[4,3,temps])/sum(MAT[4,,temps]) # proportion de malade (infectieux ou non) à la fin
    # xx
    sortie2 <- nvinf[temps] # nombre d'infection à la fin
    # xx
    sortie3 <- max(MAT[4,3,1:temps]) # ?effectif maximal de malades infectieux
    # xx
    sortie4 <- sum(nvinf[1:365]) #nombre d'infection la première année
    
    sorties[i,1] <- sortie1;
    sorties[i,2] <- sortie2;
    sorties[i,3] <- sortie3;
    sorties[i,4] <- sortie4;
    
  }# fin boucle sc?narios AS

  return(sorties)
} # fin fonction du mod?le

# END
```

  
```{r, warning=FALSE, message=FALSE}
par_name = c("K", "sr", "m1", "m2", "m3", "f2", "f3", "portee", "t1", "t2", "trans", "lat", "rec", "loss", "madd")

ValNominale = c(100, 
                0.5, 0.0014, 0.00029, 0.0019, 
                0.0019, 0.0082, 5, 1/365, 1/365, 
                0.3, 1/5, 1/20, 1/100, 0.001)

scenario_OAT =  matrix(rep(ValNominale, each = 11), nrow = 11, ncol = 15)

graph_oat = function(i, bornes){
  
  scenario_OAT_i = scenario_OAT

  if (bornes[1] != Inf){
    inf = bornes[1]
    sup = bornes[2]
    
    scenario_OAT_i[, i] = c(ValNominale[i],
                          inf + (sup-inf)  * c(0, 0.01, 0.1, 0.3, 0.4, 0.5, 0.7, 0.9, 0.99, 1)
                          )
  }
  else{
    scenario_OAT_i[, i] = ValNominale[i] * c(1,
                                             0, 1/100, 1/10, 1/5, 0.9,
                                             1.1, 2, 5, 10, 100)
  }
    res = modAppli(scenario_OAT_i)
    
    res_plot = tibble(paramettre_i = scenario_OAT_i[, i],
                  prop_inf = res[,1]/res[1,1],
                  infec_end = res[,2]/res[1,2],
                  nb_max_infec = res[,3]/res[1,3] ,
                  nb_infec_year1 = res[,4]/res[1,4])
    
    
    ggplot() +
      geom_line(data = res_plot, aes(x = paramettre_i, y = prop_inf, color = "S1"), size = 1) +
      geom_line(data = res_plot, aes(x = paramettre_i, y = infec_end, color = "S2"), size = 1) +
      geom_line(data = res_plot, aes(x = paramettre_i, y = nb_max_infec,  color = "S3"), size = 1) +
      geom_line(data = res_plot, aes(x = paramettre_i, y = nb_infec_year1,  color = "S4"), size = 1) +
      scale_x_continuous(trans='log10') +
      labs(x = "Parameter value", y = "Relative variation") +
      theme_minimal() +
      ggtitle(par_name[i])
}
```


```{r, warning=FALSE, message=FALSE, fig.dim = c(10, 7)}
ggarrange(graph_oat(i = 1, bornes = c(Inf, Inf)), graph_oat(i = 2, bornes = c(0, 1)), graph_oat(i = 3, bornes = c(0, 1)),
          graph_oat(i = 4, bornes = c(0, 1)), graph_oat(i = 4, bornes = c(0, 1)), graph_oat(i = 5, bornes = c(Inf, Inf)),
          graph_oat(i = 7, bornes = c(Inf, Inf)), graph_oat(i = 8, bornes = c(Inf, Inf)), graph_oat(i = 9, bornes = c(0, 1)),
          graph_oat(i = 10, bornes = c(0,1)), graph_oat(i = 11, bornes = c(0, 1)), graph_oat(i = 12, bornes = c(0, 1)),
          graph_oat(i = 13, bornes = c(0, 1)), graph_oat(i = 14, bornes = c(0, 1)), graph_oat(i = 15, bornes = c(0, 1)),
          ncol = 3, nrow = 5)


```
#### 3.A.

```{r}
library(sensitivity)

#PROBLEME AVEC LE FORMAT DE LA FONCTION

#x <- morris(model = modAppli, factors = 2, r = 4, design = list(type = "oat", levels = 3, grid.jump = 2))
#print(x)
#plot(x)


```



  
  
  