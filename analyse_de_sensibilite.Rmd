---
title: "Analyse de sensibilité d'une modèle de propagation d'une épidémie - MEPI"
author : "Louis Schroll & Odin Rumianowski"
date: "2023-10-05"
style : spacelab
output :
  html_document :
    style : sandstone
    toc : yes
    toc_float : yes
    warning : no
    message : no
    code_fold : hide
    
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache=TRUE)
```

```{r, include=FALSE}
library(tidyverse)
library(ggpubr)
library(sensitivity)
library(dplyr)
library(cowplot)
source(file = "functionModProjet2023.r")
```


```{r}

ValNominale = c(100, 0.5, 0.0014, 0.00029, 0.0019, 
                0.0019, 0.0082, 5, 1/365, 1/365, 
                0.3, 1/5, 1/20, 1/100, 0.001)

par_name = c("K", "sr", "m1", "m2", "m3", "f2", "f3", "portee", "t1", "t2", "trans", "lat", "rec", "loss", "madd")
```


### 1. Description du modèle

#### 1.A. Définissez le type de ce modèle
  
   Le modèle est :
   
  - **déterministe** puisque les résultats qu'il produit sont entièrement déterminés par les paramètres initiaux et les équations le décrivant, sans aucune composante aléatoire,
  
  - **à compartiment**, les individus sont groupés selon leur état de santé et leur classe d'âge,
  
  - **à un temps discret** car le temps (2 ans) est divisé en 730 jours au cours desquels les changements d'états du système ont lieux. 
  
#### 1.B. Quels sont les processus biologiques en jeu ?
  
  Le grand processus biologique modélisé est une **épidémie**.
  
  Dans ce modèle, les individus sont groupés en quatre catégories selon le stade épidémique:  
  
  1- Les individus susceptibles, notés S. Ils sont susceptibles de se faire infecter. 
  
  2- Les individus exposés (infectés/non-infectieux), notés E ou L. Ils sont dans un état latent dans lequel ils sont infectés mais pas encore contagieux.
  
  3- Les individus infectés/infectieux, notés I. Ils sont infectés et contagieux. Cette classe a un risque de mortalité additionnel lié à la maladie.
  
  4- Les individus rétablis/non-sensible, notés R. Ils ne sont plus contagieux ni susceptibles d'être infectés. Ils peuvent malgré tout perdre leur immunité et redevenir susceptibles. 
  
  Ce modèle est donc un modèle SEIRS/SLIRS (Susceptible-Exposé/Latent-Infecté-Retiré-Susceptible). Les processus biologiques représentés à travers ce modèle correspondent aux transitions entre les états et sont la **transmission** de la maladie, le temps de **latence** entre l'exposition et l'état infectieux, la **mortalité due à la maladie** ou la **récupération/immunisation** après la maladie, et la **perte d'immunité**. A ces processus liés à la maladie s'ajoute des processus démographiques : **natalité** et **mortalité naturelle** (hors maladie). 
  
  En plus des états de santé, la population est structuré en classe d'âge ayant un taux de mortalité et de fertilité propre. 

  
#### 1.C. Ecrivez les équations associées
  
 Pour la classe d'âge 1 (enfant)
  $$\left\{ 
  \begin{array}{ll}
  S_{1}(t+1)= S_{1}(t).(1-m_{1}-t_{1}-\beta.\frac{\sum_{i=1}^{3}{I_{i}(t)}}{N(t)})+\xi.R_{1}(t)+SR.P.(N_{2}(t).f_{2}+N_{3}(t).f_{3}).(1-\frac{N}{K}) \\
   E_{1}(t+1)= E_{1}(t).(1-m_{1}-t_{1}-\sigma)+S_{1}(t).\beta.\frac{\sum_{i=1}^{3}{I_{i}(t)}}{N(t)} \\
    I_{1}(t+1)= I_{1}(t).(1-m_{1}-t_{1}-\mu-\gamma)+E_{1}(t).\sigma \\
     R_{1}(t+1)= R_{1}(t).(1-m_{1}-t_{1}-\xi)+I_{1}(t).\gamma
   \end{array}
  \right.$$
  Pour la classe d'âge 2 (adulte)
  $$\left\{ 
  \begin{array}{ll}
  S_{2}(t+1)= S_{1}(t).t_{1} + S_{2}(t).(1-m_{2}-t_{2}-\beta.\frac{\sum_{i=1}^{3}{I_{i}(t)}}{N(t)})+\xi.R_{2}(t) \\
   E_{2}(t+1)= E_{1}(t).t_{1} + E_{2}(t).(1-m_{2}-t_{2}-\sigma)+S_{2}(t).\beta.\frac{\sum_{i=1}^{3}{I_{i}(t)}}{N(t)} \\
    I_{2}(t+1)= I_{1}(t).t_{1} + I_{2}(t).(1-m_{2}-t_{2}-\mu-\gamma)+E_{2}(t).\sigma \\
     R_{2}(t+1)= R_{1}(t).t_{1} + R_{2}(t).(1-m_{2}-t_{2}-\xi)+I_{2}(t).\gamma
   \end{array}
  \right.$$
  Pour la classe d'âge 3 (senior)
  $$ \left\{ 
  \begin{array}{ll}
  S_{3}(t+1)= S_{2}(t).t_{2} + S_{3}(t).(1-m_{3}\beta.\frac{\sum_{i=1}^{3}{I_{i}(t)}}{N(t)})+\xi.R_{3}(t) \\
   E_{3}(t+1)= E_{2}(t).t_{2} +  E_{3}(t).(1-m_{3}-\sigma)+S_{3}(t).\beta.\frac{\sum_{i=1}^{3}{I_{i}(t)}}{N(t)} \\
    I_{3}(t+1)= I_{2}(t).t_{2} +  I_{1}(t).(1-m_{3}-\mu-\gamma)+E_{3}(t).\sigma \\
     R_{3}(t+1)= R_{2}(t).t_{2} +  R_{3}(t).(1-m_{3}-\xi)+I_{3}(t).\gamma
   \end{array}
  \right. $$
Avec

$N_{2}(t)=S_{2}(t)+E_{2}(t)+I_{2}(t)+R_{2}(t)$

$N_{3}(t)=S_{3}(t)+E_{3}(t)+I_{3}(t)+R_{3}(t)$

$K$ : capacité de charge du milieu

$SR$ : sex ratio dans la population

$P$ : taille des portées

$m_{i}$ : taux de mortalité naturelle dans la classe d'âge i

$f_{i}$ : taux de fécondité dans la classe d'âge i

$t_{i}$ : taux de passage de la classe d'âge i à la classe d'âge i+1

$\beta$ : taux de transmission de la maladie

$\sigma$ : inverse du temps de latence

$\gamma$ : taux de récupération

$\xi$ : taux de perte d'immunité

$\mu$ : taux de mortalité due à la maladie

  

#### 1.D. Fournissez le schéma des transitions entre états concordant avec ces équations
  
  ![Texte alternatif](image/transition_stade_epidemie.png){width=50%}
  ![Texte alternatif](image/transition_classe_age.png){width=50%}

=> 1 seul schema avec tout
  
#### 1.E. Listez les hypothèses principales de ce modèle (quel type de force d’infection, population variable ou constante, etc)
  

Dans la construction du modèle, plusieurs hypothèses sont faites. Elles concernent la dynamique des populations:


 - tous les individus peuvent se reproduire (absense de sexes)
 - les variations interindividuelles ne propriétés des individus ne dépendent que de leur classe d'âge
    - la probabilité de se reproduire et le taille des portées ne dépendent que de la classe d'âge
    - le succès de reproduction dépend de la densité de population uniquement à travers une capacité de l'environnment noté K
    - le probalité intrasèque de mortalité (non-spécifique à une maladie) ne dépend que de la classe d'âge
 - les processus de migration sont négligés i.e. la population est considérée comme fermée


Les hypothèses de modélisations principales liées à la dynamique épidémiologique sont :
 
 - les propriétés épidémiologiques des individus sont identiques pour les individus, notamment qu'ils ne dépendent pas de la classe d'âge.
 - l'épidémie est structuré en quatre groupes: les sensibles, les latents, les infectieux et les guéris.
 - les paramètres épidémiologiques restent invariant au cours du temps e.g. absence d'évolution de l'agent infectieux et de l'hôte / absense de saisonalité 

  
  
  
  
#### 1.F. Quelles sont les conditions initiales ?

  Les conditions initiales du modèle sont :
  27 individus sensibles de classe d'âge 1,
  23 individus sensibles de classe d'âge 1,
  36 individus sensibles de classe d'âge 3 et
  1 individus infecté et infectieux de classe d'âge 3.
  
#### 1.G. Listez et définissez les sorties possibles du modèle
  
  Les sorties proposés sont :
  
  1- la proportion de malades i.e. infectés (infectieux ou non) à la fin de la période d'étude (deux ans)
  
  2- le nombre d'infection réalisées le dernier jour de la période d'étude
  
  3- le nombre maximum de d'infectés pendant la période d'étude
  
  4- le nombre d'infection réalisés pendant la première année de l'étude
  
  D'autres sorties possibles du modèle peuvent être :
  
  5- la proportion maximale de malades pendant la période d'étude
  
  6- le nombre d'individus sensibles à la fin de la période d'étude
  
#### 1.H. Listez les paramètres du modèle, donnez leurs définitions et leurs valeurs
  
  K : Capacité de l'environnment. Valeur au-dessus de laquelle la population ne produit plus de portée.
  
  sr : Sex-ratio (proportion de femelles)
  
  portee : taille des portées
  
  m_i : mortalité naturelle dans la classe d'âge i
  
  f_i : fécondité de la classe i
  
  t_i : probabilité de partir de la classe d'âge i pour rentrer dans la classe i+1
  
  trans : probabilité d'infection (quitter le groupe des sensibles pour devenir infecté/non-infectieux)
  
  lat : probabilité de devenir contagieux (quitter le groupe des infectés/non-infectieux pour devenir infectés/infectieux)
  
  rect: probabilité de guérir (quitter le groupe des infectés/infectieux pour devenir guéri/non-sensible)
  
  loss : probalitité de perte d'immunité (quitter le groupe des guéri/non-sensible pour redevenir sensible)
  
  madd : probabilité de mourir pendant le stade infectés/infectieux
  
  
#### 1.I. Réalisez quelques figures pour illustrer au mieux le comportement du modèle pour les valeurs nominales des paramètres

```{r}
scenario_initial <- matrix(ValNominale, nrow = 1, ncol = 15)

matrice_effectif <- modAppli_effectif(scenario_initial)

effectif_par_sante = tibble(
  temps = 1:(2 * 365),
  S = matrice_effectif[4,1, ],
  L = matrice_effectif[4,2, ],
  I = matrice_effectif[4,3, ],
  R = matrice_effectif[4,4, ],
  N = colSums(matrice_effectif[4,1:4, ]),
  ) %>%
  pivot_longer(cols = c(S, L, I, R, N), names_to = "Etat", values_to = "Effectif")

effectif_par_age = tibble(
  temps = 1:(2 * 365),
  C1 = colSums(matrice_effectif[1,1:4,]),
  C2 = colSums(matrice_effectif[2,1:4,]),
  C3 = colSums(matrice_effectif[3,1:4,]),
  ) %>%
  pivot_longer(cols = starts_with("C"), names_to = "age_class", values_to = "Effectif") %>%
  group_by(temps, age_class) %>%
  summarise(n = sum(Effectif)) %>%
  mutate(percentage = n / sum(n))
  

# Plot 1 : evolution de la dynamique epidemique
plot1 <- ggplot(effectif_par_sante, aes(x = temps, y = Effectif, color = Etat)) +
  geom_line(size = 1) +
  labs(x = "Temps", y = "Effectif") +
  theme_minimal() +
  ggtitle("Evolution de la dynamique épidémique - modèle initial")

# plot 2 : evolution de la strucutre d'age
plot2 <- ggplot(effectif_par_age,aes(x = temps, y = percentage, fill = age_class)) +
  geom_area(alpha = 0.4, size = 1, colour = "black") +
  labs(x = "Temps", y = "Effectif", fill = "Classe d'âge") +
  theme_minimal() +
  ggtitle("Evolution of age structure - Initial Model")

plot1
plot2
```


### 2. Méthode OAT
#### 2.A Justifiez les valeurs testées

Il a été fait le choix de faire varier uniformément chaque paramètre sur un intervalle avec 25% supérieure (respectivement inférieure) à la valeur nominale. L’analyse de sensibilité doit permettre d'évaluer les variations des sorties pour de faibles déviations de des paramètres. La valeur de 25% de variation nous paraît raisonnable pour chaque paramètre et a donc été choisie.


#### 2.B. Fournissez votre script
  
```{r, warning=FALSE, message=FALSE, include=TRUE}
sensivity_oat = function(lx, ly){
  diff_y = max(ly) - min(ly)
  diff_x = max(lx) - min(lx)
  return(diff_y/diff_x)
}

elascitiy_oat = function(lx, ly){
  return(sensivity_oat(lx, ly)*(mean(lx[[1]])/mean(ly[[1]])))
}
```


```{r, warning=FALSE, message=FALSE, include=TRUE}
makeAnalyseOAT <- function(ValNominale){
  sortie = createMatriceForOAT(ValNominale) %>%
    modAppli() %>%
    normaliseSortie(ValNominale)
  return(sortie)
}

createMatriceForOAT <- function(ValNominale){
  nbParametres = length(ValNominale)
  nbScenariosParParam = 11
  nbScenariosTotal = nbScenariosParParam*nbParametres
  valeurMin = ValNominale * 0.75
  valeurMax = ValNominale * 1.25

  matrixScenario =  matrix(rep(ValNominale, each = nbScenariosTotal), nrow = nbScenariosTotal, ncol = nbParametres)
  for (i in 1:nbParametres){
    i_min = nbScenariosParParam*(i-1)+1
    i_max = nbScenariosParParam*i

    matrixScenario[i_min:i_max,i] = pracma::linspace(valeurMin[i],valeurMax[i], n = nbScenariosParParam)
  }
  return(matrixScenario)
}

normaliseSortie <- function(sortie,ValNominale){
  sortieNominale = modAppli(matrix(ValNominale, nrow=1, ncol=15))
  return(data.frame(prop_inf = sortie[,1]/sortieNominale[,1],
                    infec_end = sortie[,2]/sortieNominale[,2],
                    nb_max_infec = sortie[,3]/sortieNominale[,3],
                    nb_infec_year1 = sortie[,4]/sortieNominale[,4]))
}
```


```{r, warning=FALSE, message=FALSE, include=TRUE}
resultParam_i = function(i,sortieNormalise,matrixScenario){
  
  nbScenariosParParam = 11
  i_min = nbScenariosParParam*(i-1)+1
  i_max = nbScenariosParParam*i
  resultParam_i = data.frame(parametre=matrixScenario[i_min:i_max,i],
                             prop_inf=sortieNormalise[i_min:i_max,1],
                             nb_infected_end=sortieNormalise[i_min:i_max,2],
                             nb_max_infec=sortieNormalise[i_min:i_max,3],
                             nb_infec_year1=sortieNormalise[i_min:i_max,4])
  
  return(resultParam_i)
  
}
```


```{r, warning=FALSE, message=FALSE, include=TRUE}
plotOATAnalysis <- function(i,sortieNormalise,matrixScenario){
  
  resultParam_i = resultParam_i(i,sortieNormalise,matrixScenario)
  
    p1 = ggplot() +
      geom_line(data = resultParam_i, aes(x = parametre, y = prop_inf, color = "S1"), size = 1) +
      geom_line(data = resultParam_i, aes(x = parametre, y = nb_infected_end, color = "S2"), size = 1) +
      geom_line(data = resultParam_i, aes(x = parametre, y = nb_max_infec,  color = "S3"), size = 1) +
      geom_line(data = resultParam_i, aes(x = parametre, y = nb_infec_year1,  color = "S4"), size = 1) +
      scale_x_continuous(trans='log10') +
      labs(x = "Parameter value", y = "Relative variation") +
      theme_minimal() +
      ggtitle(par_name[i])
    
      res_plot2 = tibble(group=rep(c("S1", "S2", "S3", "S4"), each=length(resultParam_i$prop_inf)),
                         value = c(resultParam_i$prop_inf,
                                  resultParam_i$nb_infected_end,
                                  resultParam_i$nb_max_infec,
                                  resultParam_i$nb_infec_year1))
    
        p2 = ggplot()+
          geom_boxplot(data=res_plot2, aes(y=value, fill = group))
        
        p3 = ggarrange(p1, p2, ncol = 2, nrow = 1)

    return(p3)
}

```


```{r, warning=FALSE, message=FALSE, include=TRUE}
matriceOAT = createMatriceForOAT(ValNominale)
sortieNormalise = makeAnalyseOAT(ValNominale)
head(sortieNormalise)
```





```{r, warning=FALSE, message=FALSE, include=TRUE}
plotOATAnalysis(i=5,sortieNormalise,matriceOAT)

```


```{r}
oat_index= tibble(parametre = NaN,
            sensibility = NaN,
            elasticity = NaN,
            sortie = NaN)

for (sortie_ in 1:4){
  
  res_s = c()
  res_e = c()
  for (i_ in 1:15){
    resultParam_i_ = resultParam_i(i=i_,sortieNormalise,matriceOAT)
    
    res_i = sensivity_oat(resultParam_i_[1], resultParam_i_[sortie_+1])
    res_s = c(res_s, res_i)
    
    res_i = elascitiy_oat(resultParam_i_[1], resultParam_i_[sortie_+1])
    res_e = c(res_e, res_i)
  }
  
  tibble_sortie_i = tibble(
         parametre = par_name,
         sensibility = res_s,
         elasticity = res_e,
         sortie = rep(paste0("S", sortie_), length(res_s)))
  
  oat_index = rbind(oat_index, tibble_sortie_i)
}

res  = oat_index[2:nrow(oat_index),]

nature_par <- c(rep("démographiques",10),rep("épidémiques",5))

s1 = ggplot()+
  geom_text(data = res %>% subset(., sortie=="S1"), aes(x = sensibility, y=elasticity, label=parametre, 
                                                        col = nature_par))+
  labs(title="S1")+ theme(legend.position = "none")

s2 = ggplot()+
  geom_text(data = res %>% subset(., sortie=="S2"), aes(x = sensibility, y=elasticity, label=parametre, 
                                                        col = nature_par))+
  labs(title="S2")+ theme(legend.position = "none")

s3 = ggplot()+
  geom_text(data = res %>% subset(., sortie=="S3"), aes(x = sensibility, y=elasticity, label=parametre, 
                                                        col = nature_par))+
  labs(title="S3")+ theme(legend.position = "none")

s4 = ggplot()+
  geom_text(data = res %>% subset(., sortie=="S4"), aes(x = sensibility, y=elasticity, label=parametre, 
                                                        col = nature_par))+
  labs(title="S4")+ theme(legend.position = "none")
```


```{r}
plot_grid(plotlist = list(s1, s2, s3, s4),ncol=2)
```


```{r, warning=FALSE, message=FALSE}
plots <- list()
nbOfPlots <- 15
for (i in 1:nbOfPlots) {
  plots[[i]] <- plotOATAnalysis(i, sortieNormalise, matriceOAT)
  show(plots[[i]])
}
```


### 3. Méthode Morris

```{r}

lowerValues = ValNominale*.75
upperValues = ValNominale*1.25

# On utilise la fonction Morris du package sensitivity
Morris <- morris(model = modAppli, 
                 factors = par_name, 
                 r = 50, 
                 scale=TRUE,
                 design = list(type = "oat", levels = 6, grid.jump = 3),
                 binf=lowerValues,
                 bsup=upperValues)
```


#### 3.a. Fournissez une figure équivalente à celle donnée dans le cours et interprétez-la. 

```{r}
get_dfMorris <- function(Morris){
  # Cette fonction sert à récupérer mu, mu* et sigma pour chaque sortie du modèle sous 
  # la forme d'un data frame
  dfMorris = getMorrisResult(Morris$ee,mean,"mu") %>%
    cbind(getMorrisResult(abs(Morris$ee),mean,"mu.star")) %>% # mu.star mesure la sensibilité 
    cbind(getMorrisResult(Morris$ee,sd,"sigma")) # sigma mesure interactions et relations non linéaires
  return(dfMorris)
}

getMorrisResult <- function(Morris_ee, functionToApply,parameter){
  # Sous fonction de get_dfMorris pour calculer mu, mu* ou sigma
  # en appliquant la methode donnée dans l'aide de la fonction morris
  df = apply(Morris_ee, 3, function(M){apply(M, 2, functionToApply)}) %>%
    as.data.frame() %>%
    renameColMorris(parameter)
}
  
renameColMorris <- function(df,parameter){
  # Sous fonction de getMorrisResult, sert à avoir des noms
  # de colonnes qui font sens
  colnames(df) <- paste0(parameter, "_S", 1:4)
  return(df)
}

plotMorris <- function(mu.star_SX,sigma_SX,title="Analyse de Morris",parametersList=par_name){
  Parametres <- c(rep("démographiques",10),rep("épidémiques",5))
  
  plot <- ggplot(data=NULL,aes(x=mu.star_SX,y=sigma_SX,col=Parametres)) +
    geom_text(aes(label=parametersList),size=2) +
    scale_color_manual(values = c("darkblue","darkred")) +
    xlab(label="mu*") +
    ylab(label="sigma") +
    labs(title = title) +
    theme_minimal()+
    theme(text = element_text(size = 6))
  return(plot)
}

dfMorris <- get_dfMorris(Morris)
plot_S1 <- plotMorris(mu.star_SX=dfMorris$mu.star_S1,sigma_SX=dfMorris$sigma_S1,
                      title="Sortie : Nombre d'infectés le dernier jour")
plot_S2 <- plotMorris(mu.star_SX=dfMorris$mu.star_S2,sigma_SX=dfMorris$sigma_S2,
                      title="Sortie : Nombre d'infection le dernier jour")
plot_S3 <- plotMorris(mu.star_SX=dfMorris$mu.star_S3,sigma_SX=dfMorris$sigma_S3,
                      title="Sortie : Nombre d'infectés sur les 2 annnées")
plot_S4 <- plotMorris(mu.star_SX=dfMorris$mu.star_S4,sigma_SX=dfMorris$sigma_S4,
                      title = "Sortie : Nombre d'infection la première année")

grid <- plot_grid(plotlist = list(plot_S1,plot_S2,plot_S3,plot_S4),ncol=2)

plot_grid(
  ggdraw() + draw_text("Analyse de Morris", x = 0.5, y = 1, vjust = 2, hjust = 0.5, size = 16),
  grid,
  ncol = 1,
  rel_heights = c(0.1, 1)
)

```



#### 3. b. Qu’en concluez-vous si vous comparez les deux approches et les résultats obtenus ?

### 4. Méthode FAST

#### 4.a. Identifiez et explicitez le package que vous utilisez pour cette analyse ; donnez les éléments les plus importants qui peuvent être modulés lors de cette analyse. Notamment, comment choisir le nombre de scénarios à réaliser ?

#### 4.b. Réalisez un premier échantillonnage avec peu de scénarios par paramètre (100). Combien cela fait-il de simulations au total ?


```{r}
scenarios_par_param = 100

q.arg4 <- Map(list, ValNominale * 0.75, ValNominale * 1.25)
names(q.arg4) <- par_name

Fast <- fast99(model = NULL, 
                 factors = par_name, 
                 n = scenarios_par_param,
                 q = rep("qunif", 15),
                 q.arg =q.arg4)

sample100 = Fast$X
head(sample100)
```



#### 4.c. Sauvegardez le tableau obtenu et réalisez un graphique illustrant les variations des paramètres obtenues.
```{r}
par(mfrow=c(2,2), mar = c(3, 3, 1, 1), cex.lab = 0.7, mgp = c(1.5, 0.5, 0))

for (i in 1:4){
  valueMin = q.arg4[[i]][[1]]
  valueMax = q.arg4[[i]][[2]]
  param = par_name[i]
  plot(sample100[,i],pch=20, cex=.7,ylab=paste(param,"value"),main=paste("Variation de",param))
  abline(h=valueMin,col="red",lty=2)
  abline(h=valueMax,col="red",lty=2)
  
  hist(sample100[,i],breaks = 100, main=paste("Répartition des valeurs pour",param))
}
```

#### 4.d. Réalisez alors un second échantillonnage avec beaucoup de scénarios par paramètre (1000). De même, sauvegardez le tableau obtenu et illustrez graphiquement votre échantillonnage.
```{r}
scenarios_par_param = 1000

Fast <- fast99(model = NULL, 
                 factors = par_name, 
                 n = scenarios_par_param,
                 q = rep("qunif", 15),
                 q.arg =q.arg4)
sample1000 = Fast$X
```


```{r}
par(mfrow=c(2,2), mar = c(3, 3, 1, 1), cex.lab = 0.7, mgp = c(1.5, 0.5, 0))

for (i in 1:4){
  valueMin = q.arg4[[i]][[1]]
  valueMax = q.arg4[[i]][[2]]
  plot(sample1000[,i],pch=20, cex=.7,ylab=paste(par_name[i],"value"),main=paste("Variation de",par_name[i]))
  abline(h=valueMin,col="red",lty=2)
  abline(h=valueMax,col="red",lty=2)
  
  hist(sample100[,i],breaks = 100, main=paste("Répartition des valeurs pour",param))

}
```

#### 4.e. Comparez les deux échantillonnages et discutez des implications possibles.
La différence principale entre les 2 échantillonages est que beaucoup plus de valeurs par paramètres sont représentées lorsqu'il y a plus de scénarios par paramètres. Par conséquent, on peut facilement imaginer que le nombre de combinaison de valeurs possibles est bien plus grand dans le cas à 1000 scénarios. A priori, plus de scenarios devraient donc donner de meilleurs estimations sur la sensibilité des paramètres, mais demandera aussi un temps de computation plus élevé.

#### 4.f. Lancez le modèle sur ces deux échantillonnages en sauvegardant bien à chaque fois les valeurs des sorties dans chaque cas.
```{r}
fast100 = modAppli(sample100)
#fast1000 = modAppli(sample1000)
```

#### 4.g. Visualisez la distribution des sorties obtenues : qu’en pensez-vous ? Quel impact dans le cadre d’une analyse de variance (telle que faite pour calculer les indices de sensibilité) ? Pouvez-vous donc interprétez toutes les sorties et pourquoi ?
```{r}
par(mfrow=c(2,2), cex.lab = 0.8,cex.main = 0.9)
title = paste("Distribution pour la sortie",
              c("1 \n (nombre d'infectés le dernier jour)",
                "2 \n (nombre d'infections le dernier jour)",
                "3 \n (nombre d'infectés sur les 2 années)",
                "4 \n (nombre d'infection la première année)"
                ))
for (i in 1:4){
  hist(sample100[,i],main=title[i],xlab="Valeurs",ylab="Fréquence",breaks=500)
}

```
On observe 2 types de distributions : distribution fortement centrée autour d'une valeur moyenne (sortie 1) et distribution plus ou moins uniforme (sortie 2 et 4). La distribution de la sortie 3 étant intermédiaire entre ces 2 formes. Une distribution centrée indique que les variations des paramètres d'entrée ont peu d'impact sur la valeur de la sortie. Au contraire, une distribution uniforme indique que les variations des paramètres d'entrée ont un effet important sur les valeurs de la sortie. Les sorties ayant ce type de distribution devraient donc être plus pertinentes pour comprendre quels paramètres d'entrée ont un effet sur la variabilité des sorties. 


#### 4.h. Pour les sorties interprétables, calculez les indices de sensibilité principaux (effet principal) et d’ordre 1 (interactions deux-à-deux) et visualisez graphiquement les résultats.

```{r}
#tell(fast100)
```


#### 4.i. Comparez les résultats des deux échantillonnages : qu’en concluez-vous ?

#### 4.j. Interprétez biologiquement le cas à 1000 scénarios par paramètre.

### 5. Discussion
####Les résultats sont-ils cohérents entre méthodes ? Quelles implications possibles ? Que feriez-vous ensuite en termes d’analyse de ce modèle ?


